/*
*   Calvin Neo
*   Copyright (C) 2016  Calvin Neo <calvinneo@calvinneo.com>
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation; either version 2 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License along
*   with this program; if not, write to the Free Software Foundation, Inc.,
*   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#include "gen_common.h"
#include <boost/algorithm/string.hpp>

std::string gen_rights(std::string filename, std::string author) {
	using namespace std;
	using namespace boost;
	string line_filename = " File: " + filename + " \n";
	string line_author = " Author: " + filename + " \n";
	string line_cfor = " Generated by CFortranTranslator \n CFortranTranslator is an open-source software under GPL license \n visit https://github.com/CalvinNeo/CFortranTranslator/ for more";

	vector<string> splitvec;
	split(splitvec, line_filename + line_author + line_cfor, is_any_of("\n"), token_compress_on);
	string content;
	int longest = 0;
	for (int i = 0; i < splitvec.size(); i++)
	{
		longest = max(longest, (int)splitvec[i].size());
	}
	for (int i = 0; i < splitvec.size(); i++)
	{
		content += "/*";
		content += splitvec[i];
		content += string(longest - splitvec[i].size(), ' ');
		content +=  "*/\n";
	}
	sprintf(codegen_buf, "/*%s*/\n%s/*%s*/\n", string(longest , '*').c_str(), content.c_str(), string(longest, '*').c_str());
	return string(codegen_buf);
}


ParseNode gen_header() {
	std::string x = gen_rights("   ", "   ");
	x += "#include \"../for90std/for90std.h\" \n";
	if (get_context().parse_config.usefor) {
		x += "#define USE_FORARRAY \n";
	}
	else {
		x += "#define USE_CARRAY \n";
	}
	ParseNode newnode = gen_token(Term{TokenMeta::META_NONTERMINAL, x.c_str()});
	return newnode;
}
m4_init()
m4_define([b4_actions], 
[b4_case(2, [b4_syncline(53, [["for90.y"]])
[    {
				]b4_lhs_value([])[.fs.CurrentTerm = Term{ TokenMeta::CRLF, "\n" };
				update_pos(]b4_lhs_value([])[);
}]])

b4_case(3, [b4_syncline(58, [["for90.y"]])
[    {
				]b4_lhs_value([])[.fs.CurrentTerm = Term{ TokenMeta::Semicolon, ";" };
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(4, [b4_syncline(63, [["for90.y"]])
[    {
				]b4_lhs_value([])[.fs.CurrentTerm = Term{ TokenMeta::Nop, "" };
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(8, [b4_syncline(73, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, "NT_VARIABLEDESC" }; // intent(in)
				newnode->attr = new VariableDescAttr(newnode);
				dynamic_cast<VariableDescAttr *>(newnode->attr)->desc.reference = true;
				dynamic_cast<VariableDescAttr *>(newnode->attr)->desc.constant = true;
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(9, [b4_syncline(83, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, "NT_VARIABLEDESC" }; // intent(out)
				newnode->attr = new VariableDescAttr(newnode);
				dynamic_cast<VariableDescAttr *>(newnode->attr)->desc.reference = true;
				dynamic_cast<VariableDescAttr *>(newnode->attr)->desc.constant = false;
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(10, [b4_syncline(94, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, "NT_VARIABLEDESC" }; // intent(inout)
				newnode->attr = new VariableDescAttr(newnode);
				dynamic_cast<VariableDescAttr *>(newnode->attr)->desc.reference = true;
				dynamic_cast<VariableDescAttr *>(newnode->attr)->desc.constant = false;
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(11, [b4_syncline(104, [["for90.y"]])
[    {
				/* if write `',' YY_DIMENSION` in `var_def` will cause conflict at ',' */
				/* if is array reduce immediately and goto `var_def` */
				/* do not parse array slices here because it can be dificult */
				ParseNode * newnode = new ParseNode();
				ParseNode * dimen = new ParseNode(]b4_rhs_value(4, 3, [])[);
				newnode->addchild(dimen); // def slice
				int sliceid = 0; /* if the array has 2 dimensions, sliceid is 0..1 */
				for (sliceid = 0; sliceid < dimen->child.size(); sliceid++)
				{
					sprintf(codegen_buf, "(%s, %s)"
						/* from, to */
						, dimen->child@{sliceid@}->child@{0@}->fs.CurrentTerm.what.c_str()
						, dimen->child@{sliceid@}->child@{1@}->fs.CurrentTerm.what.c_str());
					dimen->child@{sliceid@}->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, string(codegen_buf) };
				}
				newnode->attr = new VariableDescAttr(newnode);
				dynamic_cast<VariableDescAttr *>(newnode->attr)->desc.slice = dimen;
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(12, [b4_syncline(126, [["for90.y"]])
[    {
				/* define array like a(1) */
				ParseNode * newnode = new ParseNode();
				ParseNode * dimen = new ParseNode();
				ParseNode * slice = new ParseNode();
				ParseNode * exp = new ParseNode();
				exp->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, "1" };
				slice->addchild(exp); // slice from 1
				sprintf(codegen_buf, "%s", /* from 1, to */]b4_rhs_value(4, 3, [])[.fs.CurrentTerm.what.c_str());
				slice->addchild(new ParseNode(]b4_rhs_value(4, 3, [])[)); // slice to
				dimen->addchild(slice);
				newnode->addchild(dimen); // def slice

				int sliceid = 0; /* only 1 dimension */
				sprintf(codegen_buf, "(%s, %s)"
					/* from 1, to */
					, dimen->child@{sliceid@}->child@{0@}->fs.CurrentTerm.what.c_str()
					, dimen->child@{sliceid@}->child@{1@}->fs.CurrentTerm.what.c_str());
				dimen->child@{sliceid@}->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, string(codegen_buf) };

				newnode->attr = new VariableDescAttr(newnode);
				dynamic_cast<VariableDescAttr *>(newnode->attr)->desc.slice = dimen;
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(13, [b4_syncline(152, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, "NT_VARIABLEDESC" }; // intent(inout)
				newnode->attr = new VariableDescAttr(newnode);
				dynamic_cast<VariableDescAttr *>(newnode->attr)->desc.optional = true;
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(14, [b4_syncline(161, [["for90.y"]])
[    {
				/* const value */
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, "NT_VARIABLEDESC" }; // const
				newnode->attr = new VariableDescAttr(newnode);
				dynamic_cast<VariableDescAttr *>(newnode->attr)->desc.constant = true;
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(15, [b4_syncline(171, [["for90.y"]])
[    {
				// do nothing because we use std::string
			}]])

b4_case(16, [b4_syncline(175, [["for90.y"]])
[    {
				int kind;
				sscanf(]b4_rhs_value(3, 3, [])[.fs.CurrentTerm.what.c_str(), "%d", &kind);
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, "NT_VARIABLEDESC" }; // kind
				newnode->attr = new VariableDescAttr(newnode);
				dynamic_cast<VariableDescAttr *>(newnode->attr)->desc.kind = kind;
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(17, [b4_syncline(187, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode(]b4_rhs_value(2, 1, [])[);
				]b4_lhs_value([])[ = ]b4_rhs_value(2, 2, [])[;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(18, [b4_syncline(193, [["for90.y"]])
[    {				
				ParseNode * newnode = new ParseNode();
				ParseNode * variable_iden = & ]b4_rhs_value(3, 3, [])[;
				ParseNode & variable_iden_1 = ]b4_rhs_value(3, 2, [])[;
				/* target code of slice depend on context */
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, "NT_VARIABLEDESC" };
				/* merge attrs */
				newnode->attr = variable_iden_1.attr->clone();
				VariableDescAttr * new_a = dynamic_cast<VariableDescAttr *>(newnode->attr);
				VariableDescAttr * var_a = dynamic_cast<VariableDescAttr *>(variable_iden->attr);
				new_a->merge(*var_a);
				// TODO do not add child
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(19, [b4_syncline(209, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, "NT_VARIABLEDESC" }; 
				newnode->attr = new VariableDescAttr(newnode);
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(20, [b4_syncline(218, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode(]b4_rhs_value(1, 1, [])[);
				]b4_lhs_value([])[ = ]b4_rhs_value(1, 1, [])[;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(21, [b4_syncline(224, [["for90.y"]])
[    {				
				ParseNode * newnode = new ParseNode();
				ParseNode * variable_iden = & ]b4_rhs_value(2, 2, [])[;
				/* target code of slice depend on context */
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, "NT_VARIABLEDESC" };
				/* merge attrs */
				newnode->attr = ]b4_rhs_value(2, 1, [])[.attr->clone();
				VariableDescAttr * new_a = dynamic_cast<VariableDescAttr *>(newnode->attr);
				VariableDescAttr * var_a = dynamic_cast<VariableDescAttr *>(variable_iden->attr);
				new_a->merge(*var_a);
				// TODO do not add child
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(22, [b4_syncline(239, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, "NT_VARIABLEDESC" }; 
				newnode->attr = new VariableDescAttr(newnode);
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(23, [b4_syncline(248, [["for90.y"]])
[    {
				/* 该条目下的右部全部为单个终结符号(语法树的叶子节点), 因此$][1全部来自lex程序 */
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::Float, ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what }; // float number
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(24, [b4_syncline(255, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::Int, ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what }; // int number
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(25, [b4_syncline(261, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				// replace `'` with `"`
				string modified = "\"" + ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what.substr(1, ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what.size() - 2) + "\"";
				newnode->fs.CurrentTerm = Term{ TokenMeta::String, modified }; // string
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(26, [b4_syncline(269, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::Bool, "true" }; // bool true
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(27, [b4_syncline(275, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::Bool, "false" }; // bool false
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(28, [b4_syncline(281, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				string strcplx = ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what;
				int splitter = strcplx.find_first_of('_', 0);
				newnode->fs.CurrentTerm = Term{ TokenMeta::Complex, "forcomplex(" + strcplx.substr(0, splitter) + ", " + strcplx.substr(splitter + 1) + ") "}; // complex
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(30, [b4_syncline(293, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::UnknownVariant, ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what }; // variant
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(32, [b4_syncline(300, [["for90.y"]])
[    {
				/* array index and function name and type cast */
				string x = ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what;
				]b4_lhs_value([])[ = ]b4_rhs_value(1, 1, [])[;
			}]])

b4_case(33, [b4_syncline(307, [["for90.y"]])
[    {
				/* arr@{from : to@} */
				ParseNode * newnode = new ParseNode();
				ParseNode & lb = ]b4_rhs_value(3, 1, [])[;
				ParseNode & ub = ]b4_rhs_value(3, 3, [])[;
				/* target code of slice depend on context */
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_SLICE, "" };
				newnode->addchild(new ParseNode(lb)); // lower bound
				newnode->addchild(new ParseNode(ub)); // upper bound
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
				/*
				*/			
			}]])

b4_case(34, [b4_syncline(322, [["for90.y"]])
[    {
				/* arr@{from : to : step@} */
				ParseNode * newnode = new ParseNode();
				/* target code of slice depend on context */
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_SLICE, "" };
				newnode->addchild(new ParseNode(]b4_rhs_value(5, 1, [])[)); // lower bound
				newnode->addchild(new ParseNode(]b4_rhs_value(5, 3, [])[)); // upper bound
				newnode->addchild(new ParseNode(]b4_rhs_value(5, 5, [])[)); // step
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(35, [b4_syncline(334, [["for90.y"]])
[    {
				/* arr@{from : to : step@} */
				ParseNode * newnode = new ParseNode();
					ParseNode * lb = new ParseNode();
					lb->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, "-1" };
					ParseNode * ub = new ParseNode();
					ub->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, "-1" };
				/* target code of slice depend on context */
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_SLICE, "" };
				newnode->addchild(new ParseNode(*lb)); // lower bound
				newnode->addchild(new ParseNode(*ub)); // upper bound
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(36, [b4_syncline(349, [["for90.y"]])
[    {
				/* 1d array */
				/* arr@{from : to@} */
				ParseNode * newnode = new ParseNode();
				/* target code of slice depend on context */
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_DIMENSLICE, "" };
				ParseNode & slice = ]b4_rhs_value(1, 1, [])[;
				if (slice.child.size() == 1) {
					slice.child.push_back(nullptr);
					slice.child@{1@} = slice.child@{0@};
					ParseNode * lb = new ParseNode();
					lb->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, "1" };
					slice.child@{0@} = lb;
				}
				newnode->addchild(new ParseNode(slice)); // only 1 slice
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(37, [b4_syncline(368, [["for90.y"]])
[    {
				/* multi dimension array */
				/* arr@{from:to, from:to, ...@} */
				ParseNode * newnode = new ParseNode();
				/* target code of slice depend on context */
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_DIMENSLICE, "" };
				ParseNode & slice = ]b4_rhs_value(3, 1, [])[;
				if (slice.child.size() == 1) {
					slice.child.push_back(nullptr);
					slice.child@{1@} = slice.child@{0@};
					ParseNode * lb = new ParseNode();
					lb->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, "1" };
					slice.child@{0@} = lb;
				}
				newnode->addchild(new ParseNode(slice)); // slice
				newnode->addchild(new ParseNode(]b4_rhs_value(3, 3, [])[)); // dimen_slice
				// attention flattern_bin
				newnode = flattern_bin(newnode);
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(38, [b4_syncline(390, [["for90.y"]])
[    {
				/* argtable is used in function call */
				ParseNode * newnode = new ParseNode();
#ifndef LAZY_GEN
				sprintf(codegen_buf, "%s", ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_ARGTABLE_PURE, string(codegen_buf) };
#endif // !LAZY_GEN
				newnode->addchild(new ParseNode(]b4_rhs_value(1, 1, [])[)); // exp
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(39, [b4_syncline(402, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp = ]b4_rhs_value(3, 1, [])[;
				ParseNode & argtable = ]b4_rhs_value(3, 3, [])[;
#ifndef LAZY_GEN
				sprintf(codegen_buf, "%s, %s", ]b4_rhs_value(3, 1, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(3, 3, [])[.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_ARGTABLE_PURE, string(codegen_buf) };
#endif // !LAZY_GEN
				newnode->addchild(new ParseNode(exp)); // exp
				newnode->addchild(new ParseNode(argtable)); // argtable
				newnode = flattern_bin(newnode);
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(40, [b4_syncline(418, [["for90.y"]])
[    {
				/* function call OR array index */
				/* NOTE that array index can be A(1:2, 3:4) */
				ParseNode * newnode = new ParseNode();
				ParseNode & callable = ]b4_rhs_value(4, 1, [])[;
				ParseNode & argtable = ]b4_rhs_value(4, 3, [])[;
#ifndef LAZY_GEN
				string name;
				string x;
				if (funcname_map.find(callable.fs.CurrentTerm.what) != funcname_map.end()) {
					name = funcname_map.at(callable.fs.CurrentTerm.what);
				}
				else {
					name = callable.fs.CurrentTerm.what;
				}
				if (argtable.fs.CurrentTerm.token == TokenMeta::NT_ARGTABLE_DIMENSLICE) {
					sprintf(codegen_buf, argtable.fs.CurrentTerm.what.c_str(), name.c_str());
					newnode->fs.CurrentTerm = Term{ TokenMeta::NT_FUCNTIONARRAY,  string(codegen_buf) };
				}
				else {
					x += name;
					x += "(";
					x += argtable.fs.CurrentTerm.what;
					x += ")";
					newnode->fs.CurrentTerm = Term{ TokenMeta::NT_FUCNTIONARRAY,  x };
				}
#endif // !LAZY_GEN
				newnode->addchild(new ParseNode(callable)); // function/array name
				newnode->addchild(new ParseNode(argtable)); // argtable
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(41, [b4_syncline(452, [["for90.y"]])
[    {
				/* function call OR array index */
				ParseNode * newnode = new ParseNode();
				ParseNode & function_array = ]b4_rhs_value(1, 1, [])[;
#ifndef LAZY_GEN
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION,  function_array.fs.CurrentTerm.what };
#endif // !LAZY_GEN

				newnode->addchild(new ParseNode(function_array)); // function_array
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(42, [b4_syncline(466, [["for90.y"]])
[    {
				/* `function_array` rule has priority over this rule  */
				ParseNode * newnode = new ParseNode();
				ParseNode & exp = ]b4_rhs_value(3, 2, [])[;
#ifndef LAZY_GEN
				sprintf(codegen_buf, "( %s )", exp.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
#endif // !LAZY_GEN

				newnode->addchild(new ParseNode(exp));
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(43, [b4_syncline(480, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s + %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // +
				newnode->addchild(new ParseNode(exp2)); // tight operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(44, [b4_syncline(493, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s - %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // -
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(45, [b4_syncline(506, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s * %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // *
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(46, [b4_syncline(519, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s / %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // /
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(47, [b4_syncline(532, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "power(%s, %s)", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // **
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(48, [b4_syncline(545, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(2, 2, [])[;
				ParseNode & op = ]b4_rhs_value(2, 1, [])[;
				sprintf(codegen_buf, "(-%s)", exp1.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(op)); // (-)
				newnode->addchild(new ParseNode(exp1)); // only right operand exp
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(49, [b4_syncline(557, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(2, 2, [])[;
				ParseNode & op = ]b4_rhs_value(2, 1, [])[;
				sprintf(codegen_buf, "%s", exp1.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(op)); // (+)
				newnode->addchild(new ParseNode(exp1)); // only right operand exp
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(50, [b4_syncline(569, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s != %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // !=
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(51, [b4_syncline(582, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s != %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // !=
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(52, [b4_syncline(595, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s == %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // ==
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(53, [b4_syncline(608, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s == %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // ==
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(54, [b4_syncline(621, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s && %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // &&
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(55, [b4_syncline(634, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s || %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // ||
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(56, [b4_syncline(647, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(2, 2, [])[;
				ParseNode & op = ]b4_rhs_value(2, 1, [])[;
				sprintf(codegen_buf, "!(%s)", exp1.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(op)); // !
				newnode->addchild(new ParseNode(exp1)); // only right operand exp
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(57, [b4_syncline(659, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s > %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // >
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(58, [b4_syncline(672, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s >= %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // >=
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(59, [b4_syncline(685, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s <= %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // <=
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(60, [b4_syncline(698, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(3, 1, [])[;
				ParseNode & op = ]b4_rhs_value(3, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(3, 3, [])[;
				sprintf(codegen_buf, "%s < %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_EXPRESSION, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // <
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(61, [b4_syncline(711, [["for90.y"]])
[    { 
				// 
				ParseNode & exp = ]b4_rhs_value(1, 1, [])[;
				]b4_lhs_value([])[ = ]b4_rhs_value(1, 1, [])[;
			}]])

b4_case(62, [b4_syncline(717, [["for90.y"]])
[    {
				// may cause reduction-reduction conflict when use `variable` instead of `callable`
				// TODO : i am a little strange that `integer::a, b, c` works well because i am afraid that callable will reduce to exp from here. however according to LR(1), `::` is not in FOLLOW(exp)
				ParseNode & exp = ]b4_rhs_value(1, 1, [])[;
				]b4_lhs_value([])[ = ]b4_rhs_value(1, 1, [])[;
			}]])

b4_case(63, [b4_syncline(725, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
#ifndef LAZY_GEN
				ParseNode & dimen_slice = ]b4_rhs_value(1, 1, [])[;
				bool isdimen = false;
				int sliceid = 0; /* if the array has 2 dimensions, sliceid is 0..1 */
				dimen_slice.fs.CurrentTerm.what = "";
				for (sliceid = 0; sliceid < dimen_slice.child.size(); sliceid++)
				{
					if (sliceid != 0) {
						dimen_slice.fs.CurrentTerm.what += ", ";
					}
					if (dimen_slice.fs.CurrentTerm.token == TokenMeta::NT_DIMENSLICE) {
						// dimen_slice
						isdimen = true;
						newnode->addchild(new ParseNode(*dimen_slice.child@{sliceid@}));
						sprintf(codegen_buf, "%s, %s"
							/* from, to */
							, dimen_slice.child@{sliceid@}->child@{0@}->fs.CurrentTerm.what.c_str()
							, dimen_slice.child@{sliceid@}->child@{1@}->fs.CurrentTerm.what.c_str());
					}
					else {
						// exp
						isdimen = false;
						newnode->addchild(new ParseNode(*dimen_slice.child@{sliceid@}));
						sprintf(codegen_buf, "%s", dimen_slice.child@{sliceid@}->fs.CurrentTerm.what.c_str());
					}
					dimen_slice.fs.CurrentTerm.what += codegen_buf;
				}
				if (isdimen) {
					//sprintf(codegen_buf, "%s", dimen_slice.fs.CurrentTerm.what.c_str());
					sprintf(codegen_buf, "%%s.slice(%s)", dimen_slice.fs.CurrentTerm.what.c_str());
					newnode->fs.CurrentTerm = Term{ TokenMeta::NT_ARGTABLE_DIMENSLICE, string(codegen_buf) };
				}
				else {
					//sprintf(codegen_buf, "%%s(%s)", dimen_slice.fs.CurrentTerm.what.c_str());
					sprintf(codegen_buf, "%s", dimen_slice.fs.CurrentTerm.what.c_str());
					newnode->fs.CurrentTerm = Term{ TokenMeta::NT_ARGTABLE_PURE, string(codegen_buf) };
				}
#endif // !LAZY_GEN
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(64, [b4_syncline(769, [["for90.y"]])
[    {
				// TODO : argtable can also be empty
				ParseNode * newnode = new ParseNode();
#ifndef LAZY_GEN
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_ARGTABLE_PURE, "" };
#endif // !LAZY_GEN
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(65, [b4_syncline(780, [["for90.y"]])
[    {
				// TODO IMPORTANT
				/*
					一般来说, 可以不单独建立stmt的ParseNode, 再添加唯一的child(exp, var_def, compound_stmt等).
					但是考虑到在cpp等语言中可能出现使用,分隔多个语句的情况(这种情况是有作用的, 表明编译器可以按照自己的顺序求值)
					所以单独建立stmt节点兵添加$][1位stmt节点的唯一的儿子
				*/
				ParseNode * newnode = new ParseNode();
				ParseNode & exp = ]b4_rhs_value(2, 1, [])[;
				//(crlf.fs.CurrentTerm.token == TokenMeta::CRLF ? ";" : "")
				sprintf(codegen_buf, "%s ;", exp.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_STATEMENT, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp)); // exp
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(66, [b4_syncline(797, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & var_def = ]b4_rhs_value(2, 1, [])[;
				/* 因为var_def本身可能生成多行代码, 因此此处生成代码不应当带分号`;` */
#ifndef LAZY_GEN
				sprintf(codegen_buf, "%s ", var_def.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_STATEMENT, string(codegen_buf) };
#endif // !LAZY_GEN
				newnode->addchild(new ParseNode(var_def)); // var_def
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(71, [b4_syncline(814, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & let = ]b4_rhs_value(1, 1, [])[;
				sprintf(codegen_buf, "%s ;", let.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_STATEMENT, string(codegen_buf) };
				newnode->addchild(new ParseNode(let)); // let
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(72, [b4_syncline(824, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & jmp = ]b4_rhs_value(1, 1, [])[;
				sprintf(codegen_buf, "%s ;", jmp.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_STATEMENT, string(codegen_buf) };
				newnode->addchild(new ParseNode(jmp)); // jmp
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(82, [b4_syncline(848, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp1 = ]b4_rhs_value(4, 1, [])[;
				ParseNode & op = ]b4_rhs_value(4, 2, [])[;
				ParseNode & exp2 = ]b4_rhs_value(4, 3, [])[;
				sprintf(codegen_buf, "%s = %s", exp1.fs.CurrentTerm.what.c_str(), exp2.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::Let, string(codegen_buf) };
				newnode->addchild(new ParseNode(exp1)); // left operand exp
				newnode->addchild(new ParseNode(op)); // =
				newnode->addchild(new ParseNode(exp2)); // right operand exp
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(83, [b4_syncline(863, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_STATEMENT, "" };
				// dummy stmt
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(84, [b4_syncline(872, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & stmt = ]b4_rhs_value(1, 1, [])[;
				sprintf(codegen_buf, "%s\n", stmt.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_SUITE, string(codegen_buf) };
				newnode->addchild(new ParseNode(stmt)); // stmt
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(85, [b4_syncline(882, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & stmt = ]b4_rhs_value(2, 1, [])[;
				ParseNode & suite = ]b4_rhs_value(2, 2, [])[;
				sprintf(codegen_buf, "%s\n%s", stmt.fs.CurrentTerm.what.c_str(), suite.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_SUITE, string(codegen_buf) };
				newnode->addchild(new ParseNode(stmt)); // stmt
				newnode->addchild(new ParseNode(suite)); // suite
				newnode = flattern_bin(newnode);
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(86, [b4_syncline(895, [["for90.y"]])
[    {
				/* suite can be empty but stmt can not */
				ParseNode * newnode = new ParseNode();
				FlexState fs; fs.CurrentTerm = Term{ TokenMeta::NT_SUITE, "\n" };
				ParseNode & stmt = ParseNode(fs, newnode, nullptr);
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_SUITE, "\n" };
				newnode->addchild(new ParseNode(stmt)); // stmt
				newnode = flattern_bin(newnode);
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(93, [b4_syncline(914, [["for90.y"]])
[    {
				]b4_lhs_value([])[.fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, "" };
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(94, [b4_syncline(919, [["for90.y"]])
[    {
				]b4_lhs_value([])[.fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what };
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(95, [b4_syncline(924, [["for90.y"]])
[    {
				]b4_lhs_value([])[.fs.CurrentTerm = Term{ TokenMeta::NT_AUTOFORMATTER, "" };
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(96, [b4_syncline(929, [["for90.y"]])
[    {
				// replace `'` with `"`
				string modified = "\"" + ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what.substr(1, ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what.size() - 2) + "\"";
				]b4_lhs_value([])[.fs.CurrentTerm = Term{ TokenMeta::NT_FORMATTER, modified };
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(97, [b4_syncline(937, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & _optional_device = ]b4_rhs_value(5, 2, [])[;
				ParseNode & _optional_formatter = ]b4_rhs_value(5, 4, [])[;
				/* target code of io_info depend on context, can be either iostream/cstdio */
				newnode->fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, "" };
				newnode->addchild(new ParseNode(_optional_device)); // _optional_device
				newnode->addchild(new ParseNode(_optional_formatter)); // _optional_formatter
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(98, [b4_syncline(949, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode _optional_device = ParseNode();
				_optional_device.fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, "" };
				ParseNode _optional_formatter = ]b4_rhs_value(2, 1, [])[;
				/* target code of io_info depend on context */
				newnode->fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, "" };
				newnode->addchild(new ParseNode(_optional_device)); // _optional_device
				newnode->addchild(new ParseNode(_optional_formatter)); // _optional_formatter
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(99, [b4_syncline(964, [["for90.y"]])
[    {
				// brace is forced
				ParseNode * newnode = new ParseNode();
				ParseNode & io_info = ]b4_rhs_value(4, 2, [])[;
				ParseNode & argtable = ]b4_rhs_value(4, 3, [])[;
				ParseNode * argtbl = &argtable;
				ParseNode * formatter = io_info.child@{1@};
				if (formatter->fs.CurrentTerm.token == TokenMeta::NT_FORMATTER) {
					string fmt = io_info.child@{1@}->fs.CurrentTerm.what.substr(1, io_info.child@{1@}->fs.CurrentTerm.what.size() - 1); // strip " 
					sprintf(codegen_buf, "printf(\"%s\", %s) ;", parse_ioformatter(fmt).c_str(), argtbl->fs.CurrentTerm.what.c_str());
					newnode->fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, string(codegen_buf) };
				}
				else {
					/* NT_AUTOFORMATTER */
					string coutcode = "cout";
					/* enumerate argtable */
					// TODO the while loop is wrong, there is need for while loop. ref: var_def code
					//while (argtbl->child.size() == 2 && argtbl->child@{1@}->fs.CurrentTerm.token == TokenMeta::NT_ARGTABLE) {
						// for all non-flatterned argtable
						for (int i = 0; i < argtbl->child.size(); i++)
						{
							// for each variable in flatterned argtable
							coutcode += "<<";
							coutcode += argtbl->child@{i@}->fs.CurrentTerm.what;
						}
						// argtbl = argtbl->child@{1@};
					//}
					coutcode += ";";
					newnode->fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, coutcode };
				}
				newnode->addchild(new ParseNode(io_info)); // ioinfo
				newnode->addchild(new ParseNode(argtable)); // argtable
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(100, [b4_syncline(1001, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & io_info = ]b4_rhs_value(4, 2, [])[;
					//ParseNode & io_info = ParseNode();	
					//ParseNode _optional_device = ParseNode();
					//_optional_device.fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, "" };
					//ParseNode _optional_formatter = $][2;
					//io_info.fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, "" };
					//io_info.addchild(new ParseNode(_optional_device));
					//io_info.addchild(new ParseNode(_optional_formatter)); 
				ParseNode & argtable = ]b4_rhs_value(4, 3, [])[;
				ParseNode * argtbl = &argtable;
				ParseNode * formatter = io_info.child@{1@};
				if (formatter->fs.CurrentTerm.token == TokenMeta::NT_FORMATTER) {
					string fmt = io_info.child@{1@}->fs.CurrentTerm.what.substr(1, io_info.child@{1@}->fs.CurrentTerm.what.size() - 1); // strip " 
					sprintf(codegen_buf, "printf(\"%s\", %s) ;", parse_ioformatter(fmt).c_str(), argtbl->fs.CurrentTerm.what.c_str());
					newnode->fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, string(codegen_buf) };
				}
				else {
					/* NT_AUTOFORMATTER */
					string coutcode = "cout";
					/* enumerate argtable */
					// TODO the while loop is wrong, there is need for while loop. ref: var_def code
					//while (argtbl->child.size() == 2 && argtbl->child@{1@}->fs.CurrentTerm.token == TokenMeta::NT_ARGTABLE) {
						// for all non-flatterned argtable
						for (int i = 0; i < argtbl->child.size(); i++)
						{
							// for each variable in flatterned argtable
							coutcode += "<<";
							coutcode += argtbl->child@{i@}->fs.CurrentTerm.what;
						}
						// argtbl = argtbl->child@{1@};
					//}
					coutcode += ";";
					newnode->fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, coutcode };
				}
				newnode->addchild(new ParseNode(io_info)); // ioinfo
				newnode->addchild(new ParseNode(argtable)); // argtable
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(101, [b4_syncline(1045, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & io_info = ]b4_rhs_value(4, 2, [])[;
				ParseNode & argtable = ]b4_rhs_value(4, 3, [])[;
				ParseNode * argtbl = &argtable;
				ParseNode * formatter = io_info.child@{1@};
				if (formatter->fs.CurrentTerm.token == TokenMeta::NT_FORMATTER) {
					string fmt = io_info.child@{1@}->fs.CurrentTerm.what.substr(1, io_info.child@{1@}->fs.CurrentTerm.what.size() - 1); // strip " 
					string pointer_to;
					for (int i = 0; i < argtbl->child.size(); i++)
					{
						if (i > 0) {
							pointer_to += ",";
						}
						pointer_to += "&";
						pointer_to += argtbl->child@{i@}->fs.CurrentTerm.what;
					}
					argtbl = argtbl->child@{1@};
					sprintf(codegen_buf, "scanf(\"%s\", %s) ;", parse_ioformatter(fmt).c_str(), pointer_to.c_str());
					newnode->fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, string(codegen_buf) };
				}
				else {
					/* NT_AUTOFORMATTER */
					string cincode = "cin";
					/* enumerate argtable */
					// TODO the while loop is wrong, there is need for while loop. ref: var_def code
					//while (argtbl->child.size() == 2 && argtbl->child@{1@}->fs.CurrentTerm.token == TokenMeta::NT_ARGTABLE) {
						// for all non-flatterned argtable
						for (int i = 0; i < argtbl->child.size(); i++)
						{
							// for each variable in flatterned argtable
							cincode += ">>";
							cincode += argtbl->child@{i@}->fs.CurrentTerm.what;
						}
						// argtbl = argtbl->child@{1@};
					//}
					cincode += ";";
					newnode->fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, cincode };
				}
				newnode->addchild(new ParseNode(io_info)); // ioinfo
				newnode->addchild(new ParseNode(argtable)); // argtable
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(102, [b4_syncline(1091, [["for90.y"]])
[    {
				]b4_lhs_value([])[ = ]b4_rhs_value(3, 2, [])[;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(103, [b4_syncline(1096, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDESC, "NT_VARIABLEDESC" };
				newnode->attr = new VariableDescAttr(newnode);
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(104, [b4_syncline(1105, [["for90.y"]])
[    {
				// now translated in pre_map
				//$][1.fs.CurrentTerm.what = typename_map.at($][1.fs.CurrentTerm.what);
				]b4_lhs_value([])[ = ]b4_rhs_value(2, 1, [])[;
				ParseNode * newnode = &]b4_lhs_value([])[;
				newnode->attr = ]b4_rhs_value(2, 2, [])[.attr->clone();
				VariableDescAttr * new_a = dynamic_cast<VariableDescAttr *>(newnode->attr);
				VariableDescAttr * var_a = dynamic_cast<VariableDescAttr *>(]b4_rhs_value(2, 2, [])[.attr);
				new_a->merge(*var_a);
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(105, [b4_syncline(1117, [["for90.y"]])
[    {
				]b4_lhs_value([])[ = ]b4_rhs_value(2, 1, [])[;
				ParseNode * newnode = &]b4_lhs_value([])[;
				newnode->attr = ]b4_rhs_value(2, 2, [])[.attr->clone();
				VariableDescAttr * new_a = dynamic_cast<VariableDescAttr *>(newnode->attr);
				VariableDescAttr * var_a = dynamic_cast<VariableDescAttr *>(]b4_rhs_value(2, 2, [])[.attr);
				new_a->merge(*var_a);
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(106, [b4_syncline(1127, [["for90.y"]])
[    {
				]b4_lhs_value([])[ = ]b4_rhs_value(2, 1, [])[;
				ParseNode * newnode = &]b4_lhs_value([])[;
				newnode->attr = ]b4_rhs_value(2, 2, [])[.attr->clone();
				VariableDescAttr * new_a = dynamic_cast<VariableDescAttr *>(newnode->attr);
				VariableDescAttr * var_a = dynamic_cast<VariableDescAttr *>(]b4_rhs_value(2, 2, [])[.attr);
				new_a->merge(*var_a);
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(107, [b4_syncline(1137, [["for90.y"]])
[    {
				]b4_lhs_value([])[ = ]b4_rhs_value(2, 1, [])[;
				ParseNode * newnode = &]b4_lhs_value([])[;
				newnode->attr = ]b4_rhs_value(2, 2, [])[.attr->clone();
				VariableDescAttr * new_a = dynamic_cast<VariableDescAttr *>(newnode->attr);
				VariableDescAttr * var_a = dynamic_cast<VariableDescAttr *>(]b4_rhs_value(2, 2, [])[.attr);
				new_a->merge(*var_a);
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(108, [b4_syncline(1147, [["for90.y"]])
[    {
				]b4_lhs_value([])[ = ]b4_rhs_value(2, 1, [])[;
				ParseNode * newnode = &]b4_lhs_value([])[;
				newnode->attr = ]b4_rhs_value(2, 2, [])[.attr->clone();
				VariableDescAttr * new_a = dynamic_cast<VariableDescAttr *>(newnode->attr);
				VariableDescAttr * var_a = dynamic_cast<VariableDescAttr *>(]b4_rhs_value(2, 2, [])[.attr);
				new_a->merge(*var_a);
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(109, [b4_syncline(1157, [["for90.y"]])
[    {
				]b4_lhs_value([])[ = ]b4_rhs_value(2, 1, [])[;
				ParseNode * newnode = &]b4_lhs_value([])[;
				newnode->attr = ]b4_rhs_value(2, 2, [])[.attr->clone();
				VariableDescAttr * new_a = dynamic_cast<VariableDescAttr *>(newnode->attr);
				VariableDescAttr * var_a = dynamic_cast<VariableDescAttr *>(]b4_rhs_value(2, 2, [])[.attr);
				new_a->merge(*var_a);
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(110, [b4_syncline(1169, [["for90.y"]])
[    {
				/* array decl */
				string arr_decl = ""; string var_decl = ""; bool do_arr = false;
				ParseNode * newnode = new ParseNode();
				ParseNode & type_spec = ]b4_rhs_value(4, 1, [])[;
				ParseNode & dummy_variable_iden = ]b4_rhs_value(4, 2, [])[;
				ParseNode * ty = new ParseNode(type_spec); // type
				VariableDescAttr * vardescattr = dynamic_cast<VariableDescAttr *>(dummy_variable_iden.attr);
				ParseNode * slice = vardescattr->desc.slice;
				newnode->addchild(ty); // type
				// specify type
				/* merge type_spec and dummy_variable_iden attr */
				VariableDescAttr * ty_a = dynamic_cast<VariableDescAttr *>(type_spec.attr);
				vardescattr->merge(*ty_a);
				if (vardescattr->desc.kind != 0) {
					if (type_spec.fs.CurrentTerm.token == TokenMeta::Int_Def) {
						if (vardescattr->desc.kind == 1) {
							ty->fs.CurrentTerm.what = "char";
						}
						else if (vardescattr->desc.kind == 2) {
							ty->fs.CurrentTerm.what = "int";
						}
						else if (vardescattr->desc.kind == 4) {
							ty->fs.CurrentTerm.what = "int";
						}
						else if (vardescattr->desc.kind == 8) {
							ty->fs.CurrentTerm.what = "long long";
						}
					}
					else if (type_spec.fs.CurrentTerm.token == TokenMeta::Float_Def) {
						if (vardescattr->desc.kind == 1) {
							ty->fs.CurrentTerm.what = "float";
						}
						else if (vardescattr->desc.kind == 2) {
							ty->fs.CurrentTerm.what = "double";
						}
						else if (vardescattr->desc.kind == 4) {
							ty->fs.CurrentTerm.what = "double";
						}
						else if (vardescattr->desc.kind == 8) {
							ty->fs.CurrentTerm.what = "long double";
						}
					}
				}
				if (slice == nullptr) {
					// slice == nullptr if this is not array
					/* must assure no ParseNode * is nullptr */
					slice = new ParseNode();
					newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VOID, "" };
				}
				else {
					do_arr = true;
				}
				newnode->addchild(slice); 
				ParseNode * pn = new ParseNode(]b4_rhs_value(4, 4, [])[); // paramtable
				newnode->addchild(pn); // paramtable
				if (do_arr)
				{
					// ARRAY
					/* in cpp code, definition of an array is inherit attribute(继承属性) grammar */
					/* enumerate paramtable */
					do {
						// for all non-flatterned paramtable
#define USE_LOOP
						for (int i = 0; i < pn->child.size(); i++)
						{
							// for each variable in flatterned paramtable
							int sliceid = 0;
							sprintf(codegen_buf, "forarray<%s>", ty->fs.CurrentTerm.what.c_str());
							string type_str(codegen_buf);
							// init high dimension array
							/* though using for-loop to init a high-dimension array is verbose comparing to using constructors, i use this form because it is more clear and it can remind users of the cost of using a high dimension array */
							vector<string> this_major; /* if you want to set value of a(i0)(i1)(i2) then this major is a(i0)(i1) */
							this_major.push_back(pn->child@{i@}->child@{0@}->fs.CurrentTerm.what /* array name */);
							for (int i = 1; i < slice->child.size(); i++)
							{
								sprintf(codegen_buf, "%s(i%d)", this_major.back().c_str(), i - 1);
								this_major.push_back(string(codegen_buf));
							}
							for (sliceid = slice->child.size() - 2; sliceid >= 0 ; sliceid--)
							{
								string prev_type_str = type_str;
								sprintf(codegen_buf, "forarray< %s >", type_str.c_str());
								type_str = string(codegen_buf);
								sprintf(codegen_buf, "for(int i%d = %s; i%d < %s; i%d++){\n\t%s(i%d) = %s(%s, %s + 1);\n%s\n}\n" /* NOTE fortran is @{lower_bound, upper_bound@} cpp is @{lower_bound, upper_bound) */
									, sliceid, slice->child@{sliceid@}->child@{0@}->fs.CurrentTerm.what.c_str(), sliceid, slice->child@{sliceid@}->child@{1@}->fs.CurrentTerm.what.c_str(), sliceid
									, this_major@{sliceid@}.c_str(), sliceid, prev_type_str.c_str(), slice->child@{sliceid + 1@}->child@{0@}->fs.CurrentTerm.what.c_str(), slice->child@{sliceid + 1@}->child@{1@}->fs.CurrentTerm.what.c_str()
									, sliceid + 1 == slice->child.size() - 1 ? "" : tabber(slice->child@{sliceid + 1@}->fs.CurrentTerm.what).c_str());
								prev_type_str = type_str;
								slice->child@{sliceid@}->fs.CurrentTerm.what = string(codegen_buf);
							}
							// use it in fucntion_decl
							string var_pattern;
							if (vardescattr->desc.reference) {
								if (vardescattr->desc.constant) {
									var_pattern = "const %s & %s";
								}
								else {
									var_pattern = "%s & %s";
								}
							}
							else {
								if (vardescattr->desc.constant) {
									var_pattern = "const %s %s";
								}
								else {
									var_pattern = "%s %s";
								}
							}
							// no desc if var_def is not in paramtable
							sprintf(codegen_buf, "%s %s(%s, %s + 1);\n" , type_str.c_str(), pn->child@{i@}->child@{0@}->fs.CurrentTerm.what.c_str() /* array name */
								, slice->child@{0@}->child@{0@}->fs.CurrentTerm.what.c_str(), slice->child@{0@}->child@{1@}->fs.CurrentTerm.what.c_str() /* slice from to */);
							arr_decl += codegen_buf;
							/* set initial value */
							if (pn->child@{i@}->child@{1@}->fs.CurrentTerm.token == TokenMeta::NT_ARRAYBUILDER)
							{
								for (int abid = 0; abid < pn->child@{i@}->child@{1@}->child.size(); abid++)
								{
									ParseNode * ab = pn->child@{i@}->child@{1@}->child@{abid@};
									if (ab->fs.CurrentTerm.token == TokenMeta::NT_ARRAYBUILDER_VALUE) {
										std::string vec_size = "std::vector<int>{", vec_lb = "std::vector<int>{";
										for (int sliceid = 0; sliceid < slice->child.size(); sliceid++)
										{
											if (sliceid != 0) {
												vec_lb += ",";
												vec_size += ",";
											}
											vec_lb += slice->child@{sliceid@}->child@{0@}->fs.CurrentTerm.what;
											int lb, ub;
											sscanf(slice->child@{sliceid@}->child@{0@}->fs.CurrentTerm.what.c_str(), "%d", &lb);
											sscanf(slice->child@{sliceid@}->child@{1@}->fs.CurrentTerm.what.c_str(), "%d", &ub);
											sprintf(codegen_buf, "%d", ub - lb + 1);
											vec_size += codegen_buf;
										}
										vec_size += "}", vec_lb += "}";
										sprintf(codegen_buf, ab->fs.CurrentTerm.what.c_str() /* sth like "init_for1array(%%s, %%s, %%s, %s)\n" */
											, pn->child@{i@}->child@{0@}->fs.CurrentTerm.what.c_str() /* variable name */
											, vec_lb.c_str()
											, vec_size.c_str());
									}
									else if (ab->fs.CurrentTerm.token == TokenMeta::NT_ARRAYBUILDER_EXP) {
										string formatter = (ab->fs.CurrentTerm.what + ";\n");
										sprintf(codegen_buf, formatter.c_str(), pn->child@{i@}->child@{0@}->fs.CurrentTerm.what.c_str());
									}
									else {
										sprintf(codegen_buf, "");
									}
								}
							}
							else {
								sprintf(codegen_buf, "");
							}
							arr_decl += codegen_buf;
						}
						if (pn->child.size() >= 2)
						{
							/* if pn->child.size() == 0, this is an empty paramtable(this function takes no arguments) */
							/* if the paramtable is not flatterned pn->child@{1@} is a right-recursive paramtable node */
							pn = pn->child@{1@};
						}
					} while (pn->child.size() == 2 && pn->child@{1@}->fs.CurrentTerm.token == TokenMeta::NT_PARAMTABLE);
					newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDEFINE, arr_decl };
				}
				else {
					// SCALAR
					sprintf(codegen_buf, "%s ", ty->fs.CurrentTerm.what.c_str());
					var_decl += string(codegen_buf);
					/* enumerate paramtable */
					do {
						// for all non-flatterned paramtable
						for (int i = 0; i < pn->child.size(); i++)
						{
							if (i > 0) {
								var_decl += ", ";
							}
							ParseNode * this_variable = pn->child@{i@};
							// use it in fucntion_decl
							string var_pattern;
							if (vardescattr->desc.reference) {
								if (vardescattr->desc.constant) {
									var_pattern = "const & %s";
								}
								else {
									var_pattern = "& %s";
								}
							}
							else {
								if (vardescattr->desc.constant) {
									var_pattern = "const %s";
								}
								else {
									var_pattern = "%s";
								}
							}
							// no desc if var_def is not in paramtable
							sprintf(codegen_buf, "%s" , this_variable->child@{0@}->fs.CurrentTerm.what.c_str());

							var_decl += codegen_buf;
							/* initial value */
							if (this_variable->child@{1@}->fs.CurrentTerm.token != TokenMeta::NT_VARIABLEINITIALDUMMY) {
								/* if initial value is not dummy but `exp` */
								var_decl += " = ";
								var_decl += this_variable->child@{1@}->fs.CurrentTerm.what;
							}
							/* desc */
							this_variable->attr = vardescattr->clone();
						}
						if (pn->child.size() >= 2)
						{
							/* if pn->child.size() == 0, this is an empty paramtable(this function takes no arguments) */
							/* if the paramtable is not flatterned pn->child@{1@} is a right-recursive paramtable node */
							pn = pn->child@{1@};
						}
					} while (pn->child.size() == 2 && pn->child@{1@}->fs.CurrentTerm.token == TokenMeta::NT_PARAMTABLE);
					var_decl += ";";
#ifndef LAZY_GEN
					// sprintf(codegen_buf, "%s %s;", $][1.fs.CurrentTerm.what.c_str(), $][4.fs.CurrentTerm.what.c_str());
					newnode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEDEFINE, var_decl };
#endif // !LAZY_GEN
				}

				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(111, [b4_syncline(1395, [["for90.y"]])
[    {
				/* paramtable is used in function decl */
				/* this paramtable has only one value */
				ParseNode * newnode = new ParseNode();
				sprintf(codegen_buf, "%s", ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_PARAMTABLE, string(codegen_buf) };
					ParseNode * variablenode = new ParseNode();
					sprintf(codegen_buf, "%s", ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what.c_str());
					variablenode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEINITIAL, string(codegen_buf) };
					variablenode->addchild( new ParseNode(]b4_rhs_value(1, 1, [])[) ); // type
					FlexState fs; fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEINITIALDUMMY, string("void") };
					variablenode->addchild( new ParseNode(fs, newnode) ); // void is dummy initial
					newnode->addchild(variablenode);
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(112, [b4_syncline(1412, [["for90.y"]])
[    {
				/* initial value is required in parse tree because it can be an non-terminal `exp` */
				/* non-array initial values */
				ParseNode * newnode = new ParseNode();
				sprintf(codegen_buf, "%s = %s", ]b4_rhs_value(3, 1, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(3, 3, [])[.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_PARAMTABLE, string(codegen_buf) };
					ParseNode * variablenode = new ParseNode();
					sprintf(codegen_buf, "%s" , ]b4_rhs_value(3, 1, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(3, 3, [])[.fs.CurrentTerm.what.c_str());
					variablenode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEINITIAL, string(codegen_buf) };
					variablenode->addchild(new ParseNode(]b4_rhs_value(3, 1, [])[)); // variable
					variablenode->addchild(new ParseNode(]b4_rhs_value(3, 3, [])[)); // initial
					newnode->addchild(variablenode);
				newnode = flattern_bin(newnode);
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(113, [b4_syncline(1429, [["for90.y"]])
[    {
				/* initial value is required in parse tree because it can be an non-terminal `exp` */
				/* array initial values */
				ParseNode * newnode = new ParseNode();
				/* 因为使用forarray作为数组, 故需要知道类型信息, 不在此处赋值, 在上层的var_def赋初值 */
				sprintf(codegen_buf, "%s.init(%s)", ]b4_rhs_value(3, 1, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(3, 3, [])[.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_PARAMTABLE, string(codegen_buf) };
					ParseNode * variablenode = new ParseNode();
					sprintf(codegen_buf, "%s.init(%s)", ]b4_rhs_value(3, 1, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(3, 3, [])[.fs.CurrentTerm.what.c_str());
					variablenode->fs.CurrentTerm = Term{ TokenMeta::NT_VARIABLEINITIAL, string(codegen_buf) };
					variablenode->addchild(new ParseNode(]b4_rhs_value(3, 1, [])[)); // variable
					variablenode->addchild(new ParseNode(]b4_rhs_value(3, 3, [])[)); // initial(array_builder)
				newnode->addchild(variablenode);
				newnode = flattern_bin(newnode);
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(114, [b4_syncline(1447, [["for90.y"]])
[    {
				]b4_lhs_value([])[ = ]b4_rhs_value(1, 1, [])[;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(115, [b4_syncline(1452, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode(); 
				newnode->addchild(]b4_rhs_value(3, 1, [])[.child@{0@}); // kwargtable
				sprintf(codegen_buf, "%s, %s", ]b4_rhs_value(3, 1, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(3, 3, [])[.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_PARAMTABLE, string(codegen_buf) };
				ParseNode & pn = ]b4_rhs_value(3, 3, [])[;
				for (int i = 0; i < pn.child.size(); i++)
				{
					newnode->addchild(new ParseNode(*pn.child@{i@})); // paramtable
				}
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(116, [b4_syncline(1466, [["for90.y"]])
[    {
				/* no params */
				ParseNode * newnode = new ParseNode();
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_PARAMTABLE, "" };
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(117, [b4_syncline(1475, [["for90.y"]])
[    {
				/* something like `abs(i), i=1,4` */
				ParseNode * newnode = new ParseNode();
				newnode->addchild(new ParseNode(]b4_rhs_value(7, 1, [])[)); // exp
				newnode->addchild(new ParseNode(]b4_rhs_value(7, 3, [])[)); // index variable
				newnode->addchild(new ParseNode(]b4_rhs_value(7, 5, [])[)); // exp_from
				newnode->addchild(new ParseNode(]b4_rhs_value(7, 7, [])[)); // exp_to
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(118, [b4_syncline(1487, [["for90.y"]])
[    {
				/* give initial value */
				/* NOTE that `B(1:2:3)` can be either a single-element argtable or a exp, this can probably lead to reduction conflicts, NOW we merge rules */
				/* NOTE fortran use a 1d list to initialize a 2d(or higher) array, however, contrary to c++ and most other language does, it store them in a **conlumn - first order**. for a 2d array, it means you a order of a(1)(1)->a(2)(1)->a(lb_1)(1)->a(1)(2) */
				ParseNode * newnode = new ParseNode();
				ParseNode & argtable = ]b4_rhs_value(3, 2, [])[; 
				/* for1array<_Container_value_type> & farr, const std::vector<int> & lower_bound
				, const std::vector<int> & size, const std::vector<T> & values */
				sprintf(codegen_buf, "init_for1array(%%s, %%s, %%s, %s);\n", /* value */ argtable.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_ARRAYBUILDER_VALUE, string(codegen_buf) };
				newnode->addchild(new ParseNode(argtable)); // argtable
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(119, [b4_syncline(1502, [["for90.y"]])
[    {
				/* give generate stmt */
				ParseNode * newnode = new ParseNode();
				ParseNode * exp = ]b4_rhs_value(3, 2, [])[.child@{0@};
				ParseNode * index = ]b4_rhs_value(3, 2, [])[.child@{1@};
				ParseNode * from = ]b4_rhs_value(3, 2, [])[.child@{2@};
				ParseNode * to = ]b4_rhs_value(3, 2, [])[.child@{3@};
				sprintf(codegen_buf, "for(int %s = %s; %s < %s; %s++){\n%s(%s) = %s;\n}", index->fs.CurrentTerm.what.c_str(), from->fs.CurrentTerm.what.c_str() /* exp_from */
					, index->fs.CurrentTerm.what.c_str(), to->fs.CurrentTerm.what.c_str() /* exp_to */, index->fs.CurrentTerm.what.c_str() /* index variable inc */
					, "\t%s" /* array variable name */, index->fs.CurrentTerm.what.c_str() /* index variable */, exp->fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_ARRAYBUILDER_EXP, string(codegen_buf) };
				newnode->addchild(new ParseNode(*exp)); // exp
				newnode->addchild(new ParseNode(*index)); // index variable
				newnode->addchild(new ParseNode(*from)); // exp_from
				newnode->addchild(new ParseNode(*to)); // exp_to
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
				// TODO 
				/* rule `YY_ARRAYINITIAL_START variable '(' dimen_slice ')' YY_ARRAYINITIAL_END ` is included in this rule*/
				/* note that this two rules can not be splitted because `exp` and `variable` + '(' can cause reduction conflict */
				/* note either that `variable '(' dimen_slice ')'` is an `exp` */
			}]])

b4_case(122, [b4_syncline(1527, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->addchild(new ParseNode(]b4_rhs_value(1, 1, [])[)); // array_builder_elem
				sprintf(codegen_buf, "%s", ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_ARRAYBUILDER, string(codegen_buf) };
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(123, [b4_syncline(1536, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->addchild(new ParseNode(]b4_rhs_value(3, 1, [])[)); // array_builder_elem
				newnode->addchild(new ParseNode(]b4_rhs_value(3, 3, [])[)); // array_builder
				sprintf(codegen_buf, "%s\n%s", ]b4_rhs_value(3, 1, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(3, 3, [])[.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_ARRAYBUILDER, string(codegen_buf) };
				newnode = flattern_bin(newnode);
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(124, [b4_syncline(1548, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp = ]b4_rhs_value(8, 2, [])[;
				ParseNode & suite_true = ]b4_rhs_value(8, 5, [])[; suite_true.fs.CurrentTerm.what = tabber(suite_true.fs.CurrentTerm.what);
#ifndef LAZY_GEN
				sprintf(codegen_buf, "if (%s) {\n%s}", exp.fs.CurrentTerm.what.c_str(), suite_true.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_IF, string(codegen_buf) };
#endif // !LAZY_GEN

				newnode->addchild(new ParseNode(]b4_rhs_value(8, 1, [])[)); // if
				newnode->addchild(new ParseNode(exp)); // exp
				newnode->addchild(new ParseNode(suite_true)); // suite
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(125, [b4_syncline(1564, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp = ]b4_rhs_value(11, 2, [])[;
				ParseNode & suite_true = ]b4_rhs_value(11, 5, [])[; suite_true.fs.CurrentTerm.what = tabber(suite_true.fs.CurrentTerm.what);
				ParseNode & suite_else = ]b4_rhs_value(11, 8, [])[; suite_else.fs.CurrentTerm.what = tabber(suite_else.fs.CurrentTerm.what);
#ifndef LAZY_GEN
				sprintf(codegen_buf, "if (%s) {\n%s}\nelse {\n %s}", exp.fs.CurrentTerm.what.c_str(), suite_true.fs.CurrentTerm.what.c_str(), suite_else.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_IF, string(codegen_buf) };
#endif // !LAZY_GEN

				newnode->addchild(new ParseNode(]b4_rhs_value(11, 1, [])[)); // if
				newnode->addchild(new ParseNode(exp)); // exp
				newnode->addchild(new ParseNode(suite_true)); // suite
				newnode->addchild(new ParseNode(]b4_rhs_value(11, 6, [])[)); // else
				newnode->addchild(new ParseNode(suite_else)); // else-stmt
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(126, [b4_syncline(1583, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp = ]b4_rhs_value(9, 2, [])[;
				ParseNode & suite_true = ]b4_rhs_value(9, 5, [])[; suite_true.fs.CurrentTerm.what = tabber(suite_true.fs.CurrentTerm.what);
				ParseNode & elseif = ]b4_rhs_value(9, 6, [])[;
#ifndef LAZY_GEN
				sprintf(codegen_buf, "if (%s) {\n%s}\n%s", exp.fs.CurrentTerm.what.c_str(), suite_true.fs.CurrentTerm.what.c_str(), elseif.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_IF, string(codegen_buf) };
#endif // !LAZY_GEN

				newnode->addchild(new ParseNode(]b4_rhs_value(9, 1, [])[)); // if
				newnode->addchild(new ParseNode(exp)); // exp
				newnode->addchild(new ParseNode(suite_true)); // suite
				newnode->addchild(new ParseNode(elseif)); // recursive elseif-stmt
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(127, [b4_syncline(1601, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp = ]b4_rhs_value(12, 2, [])[;
				ParseNode & suite_true = ]b4_rhs_value(12, 5, [])[; suite_true.fs.CurrentTerm.what = tabber(suite_true.fs.CurrentTerm.what);
				ParseNode & elseif = ]b4_rhs_value(12, 6, [])[;
				ParseNode & suite_else = ]b4_rhs_value(12, 9, [])[; suite_else.fs.CurrentTerm.what = tabber(suite_else.fs.CurrentTerm.what);
				
#ifndef LAZY_GEN
				sprintf(codegen_buf, "if (%s) {\n%s}\n%selse {\n%s}", exp.fs.CurrentTerm.what.c_str(), suite_true.fs.CurrentTerm.what.c_str(), elseif.fs.CurrentTerm.what.c_str(), suite_else.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_IF, string(codegen_buf) };
#endif // !LAZY_GEN

				newnode->addchild(new ParseNode(]b4_rhs_value(12, 1, [])[)); // if
				newnode->addchild(new ParseNode(exp)); // exp
				newnode->addchild(new ParseNode(suite_true)); // suite
				newnode->addchild(new ParseNode(elseif)); // recursive elseif-stmt
				newnode->addchild(new ParseNode(suite_else)); // else-stmt
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(128, [b4_syncline(1622, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp = ]b4_rhs_value(4, 2, [])[;
				ParseNode & stmt_true = ]b4_rhs_value(4, 4, [])[; 
#ifndef LAZY_GEN
				sprintf(codegen_buf, "if (%s) %s", exp.fs.CurrentTerm.what.c_str(), stmt_true.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_IF, string(codegen_buf) };
#endif // !LAZY_GEN

				newnode->addchild(new ParseNode(]b4_rhs_value(4, 1, [])[)); // if
				newnode->addchild(new ParseNode(exp)); // exp
				newnode->addchild(new ParseNode(stmt_true)); // stmt
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(129, [b4_syncline(1638, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp = ]b4_rhs_value(5, 2, [])[;
				ParseNode & suite_true = ]b4_rhs_value(5, 5, [])[; suite_true.fs.CurrentTerm.what = tabber(suite_true.fs.CurrentTerm.what);
#ifndef LAZY_GEN
				sprintf(codegen_buf, "else if(%s) {\n%s}", exp.fs.CurrentTerm.what.c_str(), suite_true.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_ELSEIF, string(codegen_buf) };
#endif // !LAZY_GEN

				newnode->addchild(new ParseNode(]b4_rhs_value(5, 1, [])[)); // elseif
				newnode->addchild(new ParseNode(exp)); // exp
				newnode->addchild(new ParseNode(suite_true)); // suite
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(130, [b4_syncline(1655, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp = ]b4_rhs_value(6, 2, [])[;
				ParseNode & suite_true = ]b4_rhs_value(6, 5, [])[; suite_true.fs.CurrentTerm.what = tabber(suite_true.fs.CurrentTerm.what);
				ParseNode & elseif = ]b4_rhs_value(6, 6, [])[;
#ifndef LAZY_GEN
				sprintf(codegen_buf, "else if{\n%s}\n%s", exp.fs.CurrentTerm.what.c_str(), suite_true.fs.CurrentTerm.what.c_str(), elseif.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_ELSEIF, string(codegen_buf) };
#endif // !LAZY_GEN

				newnode->addchild(new ParseNode(]b4_rhs_value(6, 1, [])[)); // elseif
				newnode->addchild(new ParseNode(exp)); // exp
				newnode->addchild(new ParseNode(suite_true)); // suite
				newnode->addchild(new ParseNode(elseif)); // another elseif-stmt
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(131, [b4_syncline(1673, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & suite = ]b4_rhs_value(6, 3, [])[; suite.fs.CurrentTerm.what = tabber(suite.fs.CurrentTerm.what);
#ifndef LAZY_GEN
				sprintf(codegen_buf, "do{\n%s}", suite.fs.CurrentTerm.what.c_str());
#endif // !LAZY_GEN

				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_DO, string(codegen_buf) };
				newnode->addchild(new ParseNode(]b4_rhs_value(6, 1, [])[)); // do
				newnode->addchild(new ParseNode(suite)); // suite
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(132, [b4_syncline(1687, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & variable = ]b4_rhs_value(11, 2, [])[;
				ParseNode & exp_from = ]b4_rhs_value(11, 4, [])[;
				ParseNode & exp_to = ]b4_rhs_value(11, 6, [])[;
				ParseNode & suite = ]b4_rhs_value(11, 8, [])[; suite.fs.CurrentTerm.what = tabber(suite.fs.CurrentTerm.what);
#ifndef LAZY_GEN
				sprintf(codegen_buf, "for(%s = %s; %s <= %s; %s++){\n%s}", variable.fs.CurrentTerm.what.c_str(), exp_from.fs.CurrentTerm.what.c_str()
					, variable.fs.CurrentTerm.what.c_str(), exp_to.fs.CurrentTerm.what.c_str()
					, variable.fs.CurrentTerm.what.c_str(), suite.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_DO, string(codegen_buf) };
#endif // !LAZY_GEN

				newnode->addchild(new ParseNode(]b4_rhs_value(11, 1, [])[)); // do
				newnode->addchild(new ParseNode(variable)); // varname
				newnode->addchild(new ParseNode(exp_from)); // begin
				newnode->addchild(new ParseNode(exp_to)); // end
				newnode->addchild(new ParseNode(suite)); // suite
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(133, [b4_syncline(1709, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				]b4_rhs_value(13, 9, [])[.fs.CurrentTerm.what = tabber(]b4_rhs_value(13, 9, [])[.fs.CurrentTerm.what);
#ifndef LAZY_GEN
				sprintf(codegen_buf, "for(%s = %s; %s <= %s; %s+=%s){\n%s}", ]b4_rhs_value(13, 2, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(13, 4, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(13, 2, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(13, 6, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(13, 2, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(13, 8, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(13, 9, [])[.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_DO, string(codegen_buf) };
#endif // !LAZY_GEN

				newnode->addchild(new ParseNode(]b4_rhs_value(13, 1, [])[)); // do
				newnode->addchild(new ParseNode(]b4_rhs_value(13, 2, [])[)); // varname
				newnode->addchild(new ParseNode(]b4_rhs_value(13, 4, [])[)); // begin
				newnode->addchild(new ParseNode(]b4_rhs_value(13, 6, [])[)); // end
				newnode->addchild(new ParseNode(]b4_rhs_value(13, 8, [])[)); // step
				newnode->addchild(new ParseNode(]b4_rhs_value(13, 9, [])[)); // suite
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(134, [b4_syncline(1727, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & exp = ]b4_rhs_value(7, 2, [])[;
				ParseNode & suite = ]b4_rhs_value(7, 4, [])[; suite.fs.CurrentTerm.what = tabber(suite.fs.CurrentTerm.what);
#ifndef LAZY_GEN
				sprintf(codegen_buf, "while(%s){\n%s}", exp.fs.CurrentTerm.what.c_str(), suite.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::While, string(codegen_buf) };
#endif // !LAZY_GEN
				newnode->addchild(new ParseNode(]b4_rhs_value(7, 1, [])[)); // while
				newnode->addchild(new ParseNode(exp)); // exp
				newnode->addchild(new ParseNode(suite)); // suite
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(135, [b4_syncline(1743, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & select = ]b4_rhs_value(10, 1, [])[;
				ParseNode & exp = ]b4_rhs_value(10, 4, [])[;
				ParseNode & case_stmt = ]b4_rhs_value(10, 7, [])[;

#ifndef LAZY_GEN
				string codegen = "";
				for (int i = 0; i < case_stmt.child.size(); i++)
				{
					ParseNode & case_stmt_elem = *case_stmt.child@{i@};
					ParseNode & dimen_slice = *case_stmt_elem.child@{1@};
					/*
						0 -- case
						1 -- dimen_slice
						2 -- stmt(case body)
					*/
					if (dimen_slice.fs.CurrentTerm.token == TokenMeta::NT_DIMENSLICE) {
						// NT_DIMENSLICE
						string dsstr;
						for (int sliceid = 0; sliceid < dimen_slice.child.size(); sliceid++)
						{
							if (sliceid == 0) {
								sprintf(codegen_buf, "(%s >= %s && %s < %s)", exp.fs.CurrentTerm.what.c_str(), dimen_slice.child@{sliceid@}->child@{0@}->fs.CurrentTerm.what.c_str(), exp.fs.CurrentTerm.what.c_str(), dimen_slice.child@{sliceid@}->child@{1@}->fs.CurrentTerm.what.c_str());
							}
							else {
								sprintf(codegen_buf, " || (%s >= %s && %s < %s)", exp.fs.CurrentTerm.what.c_str(), dimen_slice.child@{sliceid@}->child@{0@}->fs.CurrentTerm.what.c_str(), exp.fs.CurrentTerm.what.c_str(), dimen_slice.child@{sliceid@}->child@{1@}->fs.CurrentTerm.what.c_str());
							}
							dsstr += string(codegen_buf);
						}
						if (i == 0) {
							sprintf(codegen_buf, "if(%s){\n%s}\n", dsstr.c_str(), case_stmt_elem.child@{2@}->fs.CurrentTerm.what.c_str());
						}
						else {
							sprintf(codegen_buf, "else if(%s){\n%s}\n", dsstr.c_str(), case_stmt_elem.child@{2@}->fs.CurrentTerm.what.c_str());
						}
					}
					else {
						// NT_ARGTABLE_PURE
						string choice = "";
						if (i == 0) {
							choice = "if(";
							sprintf(codegen_buf, "if(%s == %s){\n%s}\n", exp.fs.CurrentTerm.what.c_str(), dimen_slice.child@{0@}->fs.CurrentTerm.what.c_str(), case_stmt_elem.child@{2@}->fs.CurrentTerm.what.c_str());
						}
						else {
							choice = "else if(";
							sprintf(codegen_buf, "else if(%s == %s){\n%s}\n", exp.fs.CurrentTerm.what.c_str(), dimen_slice.child@{0@}->fs.CurrentTerm.what.c_str(), case_stmt_elem.child@{2@}->fs.CurrentTerm.what.c_str());
						}
						for (int j = 0; j < dimen_slice.child.size(); j++)
						{
							if (j == 0) {
								sprintf(codegen_buf, "%s == %s", exp.fs.CurrentTerm.what.c_str(), dimen_slice.child@{j@}->fs.CurrentTerm.what.c_str());
							}
							else {
								sprintf(codegen_buf, "|| (%s == %s)", exp.fs.CurrentTerm.what.c_str(), dimen_slice.child@{j@}->fs.CurrentTerm.what.c_str());
							}
							choice += codegen_buf;
						}
						sprintf(codegen_buf, "){\n%s}\n", case_stmt_elem.child@{2@}->fs.CurrentTerm.what.c_str());
						choice += codegen_buf;
						sprintf(codegen_buf, "%s", choice.c_str());
					}
					codegen += codegen_buf;
				}
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_SELECT, codegen };
#endif // !LAZY_GEN
				newnode->addchild(new ParseNode(select)); // select
				newnode->addchild(new ParseNode(exp)); // exp
				newnode->addchild(new ParseNode(case_stmt)); // suite
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(136, [b4_syncline(1816, [["for90.y"]])
[    {
				// one case
				ParseNode * newnode = new ParseNode();
				ParseNode & case_head = ]b4_rhs_value(6, 1, [])[;
				ParseNode & dimen_slice = ]b4_rhs_value(6, 3, [])[;
				ParseNode & suite = ]b4_rhs_value(6, 6, [])[; suite.fs.CurrentTerm.what = tabber(suite.fs.CurrentTerm.what);
#ifndef LAZY_GEN
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_CASE, "" };
#endif // !LAZY_GEN
				newnode->addchild(new ParseNode(case_head)); // case
				newnode->addchild(new ParseNode(dimen_slice)); // dimen_slice
				newnode->addchild(new ParseNode(suite)); // suite
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(137, [b4_syncline(1832, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				ParseNode & case_stmt_elem = ]b4_rhs_value(1, 1, [])[;
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_CASES, "" };
				newnode->addchild(new ParseNode(case_stmt_elem)); // case_stmt_elem
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(138, [b4_syncline(1841, [["for90.y"]])
[    {
				ParseNode & case_stmt_elem = ]b4_rhs_value(2, 1, [])[;
				ParseNode & case_stmt = ]b4_rhs_value(2, 2, [])[;
				ParseNode * newnode = new ParseNode(case_stmt);
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_CASES, "" };
				newnode->addchild(new ParseNode(case_stmt_elem), false); // case_stmt_elem
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(139, [b4_syncline(1853, [["for90.y"]])
[    {
				/* fortran90 does not declare type of arguments in function declaration statement*/
				ParseNode * newnode = new ParseNode();
				vector<tuple<string, string, ParseNode *>> param_name_typename; // all params in paramtable of function declare (var_name, var_type)
				ParseNode & variable_function = ]b4_rhs_value(15, 3, [])[;
				/* enumerate paramtable */
				ParseNode & paramtable = ]b4_rhs_value(15, 5, [])[;
				ParseNode * prmtbl = &paramtable;
				vector<ParseNode *> param_definition;
				ParseNode & variable_result = ]b4_rhs_value(15, 9, [])[;
				ParseNode & suite = ]b4_rhs_value(15, 12, [])[;

				// log function in function table
				add_function("", variable_function.fs.CurrentTerm.what, nullptr);

				do {
					// for all non-flatterned paramtable
					for (int i = 0; i < prmtbl->child.size(); i++)
					{
						// for each variable in flatterned paramtable
						param_name_typename.push_back(make_tuple(prmtbl->child@{i@}->fs.CurrentTerm.what, "void", nullptr)); // refer to function suite and determine type of params
					}
					if (prmtbl->child.size() >= 2)
					{
						/* if prmtbl->child.size() == 0, this is an empty paramtable(this function takes no arguments) */
						/* if the paramtable is not flatterned prmtbl->child@{1@} is a right-recursive paramtable node */
						prmtbl = prmtbl->child@{1@};
					}
				} while (prmtbl->child.size() == 2 && prmtbl->child@{1@}->fs.CurrentTerm.token == TokenMeta::NT_PARAMTABLE);
				/* result variable */
				param_name_typename.push_back(make_tuple(variable_result.fs.CurrentTerm.what, "void", nullptr));
				/* find out all var_def nodes */
				for (int i = 0; i < suite.child.size(); i++)
				{
					ParseNode * stmti = suite.child@{i@};
					/* suite.child@{i@} => stmt */ 
					/*  REF stmt for why stmt is a node always with 1 child(except for dummy stmt) */
					if (stmti->child.size() == 1 && stmti->child@{0@}->fs.CurrentTerm.token == TokenMeta::NT_VARIABLEDEFINE) {
						/* stmti->child@{0@} => var_def */
						/* from pn=stmti->child@{0@}.child@{0@} is typename */
						/* from pn=stmti->child@{0@}.child@{1@} is dimen_slice */
						/* from pn=stmti->child@{0@}.child@{2@} is all variables of this type */
						ParseNode * pn = stmti->child@{0@}->child@{2@};
						do {
							// for all non-flatterned paramtable
							for (int i = 0; i < pn->child.size(); i++)
							{
								// for each variable in flatterned paramtable
								/* pn->child@{i@} is varname_i with initial value */
								/* pn->child@{i@}->child@{0@} is varname string */
								param_definition.push_back(pn->child@{i@}->child@{0@});
							}
							if (pn->child.size() >= 2)
							{
								/* if pn->child.size() == 0, this is an empty paramtable(this function takes no arguments) */
								/* if the paramtable is not flatterned pn->child@{1@} is a right-recursive paramtable node */
								pn = pn->child@{1@};
							}
						} while (pn->child.size() == 2 && pn->child@{1@}->fs.CurrentTerm.token == TokenMeta::NT_PARAMTABLE);
					}
				}

				/* set type to all param_name_typename */
				for (int i = 0; i < param_name_typename.size(); i++)
				{
					string varname = get<0>(param_name_typename@{i@});
					for (int j = 0; j < param_definition.size(); j++)
					{
						ParseNode * varname_node = param_definition@{j@};
						if (varname_node->fs.CurrentTerm.what == varname) {
							//	father		NT_VARIABLEINITIAL (variable_name, variable_initial_value)
							//	father * 2	NT_PARAMTABLE
							//	father * 3	NT_VARIABLEDEFINE var_def
							//  param_name_typename@{i@} = tuple<name, type, ParseNode *>
							get<1>(param_name_typename@{i@}) = varname_node->father->father->father->child@{0@}->fs.CurrentTerm.what;
							get<2>(param_name_typename@{i@}) = varname_node->father;
							/* `delete` ParseNode except return value */
							if (i != param_name_typename.size() - 1) {
								varname_node->father->fs.CurrentTerm.token = TokenMeta::NT_DECLAREDVARIABLE;
							}
						}
					}
				}

				/* generate new paramtable with type */
				string argtblstr;
				for (int i = 0; i < param_name_typename.size() - 1 /* exclude YY_RESULT(return value) */; i++)
				{
					if(i != 0)
						argtblstr += ", ";
					VariableDescAttr * vardescattr = dynamic_cast<VariableDescAttr *>( get<2>(param_name_typename@{i@})->attr );
					if (vardescattr != nullptr)
					{
						if (vardescattr->desc.constant) {
							argtblstr += "const ";
						}
						else {
						}
					}
					argtblstr += get<1>(param_name_typename@{i@});
					argtblstr += " ";
					if (vardescattr != nullptr)
					{
						if (vardescattr->desc.reference) {
							argtblstr += "& ";
						}
						else {
						}
					}
					argtblstr += get<0>(param_name_typename@{i@});
				}

				/* add type infomation to paramtable ParseNodes  */
				ParseNode * newpt; // paramtable is raw for90 paramtable without type
				// TODO This is optional so i decide not to implement currently
				/* generate new return with type */
				ParseNode * newrt; // variable_result is raw for90 return without type
				// TODO This is optional so i decide not to implement currently
				
				/* re-generated codes of suite */
				string newsuitestr; // suite is raw for90 suite without type
				ParseNode * oldsuite = &suite;
				for (int i = 0; i < oldsuite->child.size(); i++)
				{
					if (oldsuite->child@{i@}->child.size() > 0 && oldsuite->child@{i@}->child@{0@}->fs.CurrentTerm.token == TokenMeta::NT_VARIABLEDEFINE)
					{
						// this code is similar to `find out all var_def nodes` code
						//ParseNode * pn = oldsuite->child@{0@}->child@{1@};
						ParseNode * typeinfo = oldsuite->child@{i@}->child@{0@}->child@{0@};
						ParseNode * pn = oldsuite->child@{i@}->child@{0@}->child@{2@};
						do {
							// for all non-flatterned paramtable
							for (int j = 0; j < pn->child.size(); j++)
							{
								// for each variable in flatterned paramtable
								/* pn->child@{i@} is varname with initial value */
								/* pn->child@{i@}->child@{0@} is varname string */
								if (pn->child@{j@}->fs.CurrentTerm.token == TokenMeta::NT_VARIABLEINITIAL) {
									//newsuitestr += oldsuite->child@{i@}->child@{0@}->fs.CurrentTerm.what; // deprecated THIS IS NT_VARIABLEDEFINE, but different variables can be different
									newsuitestr += typeinfo->fs.CurrentTerm.what;
									newsuitestr += " ";
									newsuitestr += pn->child@{j@}->child@{0@}->fs.CurrentTerm.what;
									if (pn->child@{j@}->child@{1@}->fs.CurrentTerm.token != TokenMeta::NT_VARIABLEINITIALDUMMY) {
										newsuitestr += " = ";
										newsuitestr += pn->child@{j@}->child@{1@}->fs.CurrentTerm.what;
									}
									newsuitestr += " ;\n";
								}
							}
							if (pn->child.size() >= 2)
							{
								/* if pn->child.size() == 0, this is an empty paramtable(this function takes no arguments) */
								/* if the paramtable is not flatterned pn->child@{1@} is a right-recursive paramtable node */
								pn = pn->child@{1@};
							}
						} while (pn->child.size() == 2 && pn->child@{1@}->fs.CurrentTerm.token == TokenMeta::NT_PARAMTABLE);
					}
					else {
						newsuitestr += oldsuite->child@{i@}->fs.CurrentTerm.what;
						newsuitestr += '\n';
					}
				}
				// update oldsuite->fs.CurrentTerm.what
				oldsuite->fs.CurrentTerm.what = tabber(newsuitestr);
				/* generate function ParseTree */
				newnode->addchild(new ParseNode(]b4_rhs_value(15, 2, [])[)); // function
				newnode->addchild(new ParseNode(variable_function)); // function name
				// argtable
				// TODO 
				// return value
				newnode->addchild(new ParseNode(suite)); // trimed suite

				sprintf(codegen_buf, "%s %s(%s)\n{%s\n}"
					, get<1>(param_name_typename@{param_name_typename.size()-1@}).c_str() // return value type
					, variable_function.fs.CurrentTerm.what.c_str() // function name
					, argtblstr.c_str() // argtable
					, oldsuite->fs.CurrentTerm.what.c_str() // code
				);
				/* generate function code */
				newnode->fs.CurrentTerm = Term{ TokenMeta::NT_FUNCTIONDECLARE, string(codegen_buf) };
				]b4_lhs_value([])[ = *newnode;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(142, [b4_syncline(2041, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->addchild(new ParseNode(]b4_rhs_value(8, 4, [])[)); //suite
				sprintf(codegen_buf, "int main(){\n%s\treturn 0;\n}", tabber(]b4_rhs_value(8, 4, [])[.fs.CurrentTerm.what).c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, string(codegen_buf) };
				]b4_lhs_value([])[ = *newnode;
			}]])

b4_case(143, [b4_syncline(2051, [["for90.y"]])
[    {
				sprintf(codegen_buf, "%s", ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what.c_str());
				]b4_lhs_value([])[ = ]b4_rhs_value(1, 1, [])[;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(144, [b4_syncline(2057, [["for90.y"]])
[    {
				sprintf(codegen_buf, "%s", ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what.c_str());
				]b4_lhs_value([])[ = ]b4_rhs_value(1, 1, [])[;
				update_pos(]b4_lhs_value([])[);
			}]])

b4_case(145, [b4_syncline(2065, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->addchild(new ParseNode(]b4_rhs_value(1, 1, [])[)); //wrapper
				sprintf(codegen_buf, "%s", ]b4_rhs_value(1, 1, [])[.fs.CurrentTerm.what.c_str());
				newnode->fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, string(codegen_buf) };
				program_tree = *newnode;
			}]])

b4_case(146, [b4_syncline(2074, [["for90.y"]])
[    {
				ParseNode * newnode = new ParseNode();
				newnode->addchild(new ParseNode(]b4_rhs_value(2, 1, [])[)); //wrapper
				newnode->addchild(new ParseNode(]b4_rhs_value(2, 2, [])[)); //fortran_program
				sprintf(codegen_buf, "%s\n%s", ]b4_rhs_value(2, 1, [])[.fs.CurrentTerm.what.c_str(), ]b4_rhs_value(2, 2, [])[.fs.CurrentTerm.what.c_str());
				newnode = flattern_bin(newnode);
				newnode->fs.CurrentTerm = Term{ TokenMeta::META_NONTERMINAL, string(codegen_buf) };
				program_tree = *newnode;
			}]])

])

m4_define([b4_mergers], 
[[]])

m4_define([b4_tokens], 
[[[[_YY_VOID]], 258],
[[[YY_REQ_MORE]], 259],
[[[YY_CRLF]], 260],
[[[_YY_OP]], 261],
[[[YY_GT]], 262],
[[[YY_GE]], 263],
[[[YY_EQ]], 264],
[[[YY_LE]], 265],
[[[YY_LT]], 266],
[[[YY_NEQ]], 267],
[[[YY_NEQV]], 268],
[[[YY_EQV]], 269],
[[[YY_ANDAND]], 270],
[[[YY_OROR]], 271],
[[[YY_NOT]], 272],
[[[YY_POWER]], 273],
[[[YY_DOUBLECOLON]], 274],
[[[YY_NEG]], 275],
[[[YY_POS]], 276],
[[[_YY_TYPE]], 277],
[[[YY_INTEGER]], 278],
[[[YY_FLOAT]], 279],
[[[YY_WORD]], 280],
[[[YY_OPERATOR]], 281],
[[[YY_STRING]], 282],
[[[YY_ILLEGAL]], 283],
[[[YY_COMPLEX]], 284],
[[[YY_TRUE]], 285],
[[[YY_FALSE]], 286],
[[[_YY_CONTROL]], 287],
[[[YY_END]], 288],
[[[YY_IF]], 289],
[[[YY_THEN]], 290],
[[[YY_ELSE]], 291],
[[[YY_ELSEIF]], 292],
[[[YY_ENDIF]], 293],
[[[YY_DO]], 294],
[[[YY_ENDDO]], 295],
[[[YY_CONTINUE]], 296],
[[[YY_BREAK]], 297],
[[[YY_WHILE]], 298],
[[[YY_ENDWHILE]], 299],
[[[YY_WHERE]], 300],
[[[YY_ENDWHERE]], 301],
[[[YY_CASE]], 302],
[[[YY_ENDCASE]], 303],
[[[YY_SELECT]], 304],
[[[YY_ENDSELECT]], 305],
[[[YY_GOTO]], 306],
[[[YY_DOWHILE]], 307],
[[[YY_DEFAULT]], 308],
[[[_YY_DELIM]], 309],
[[[YY_PROGRAM]], 310],
[[[YY_ENDPROGRAM]], 311],
[[[YY_FUNCTION]], 312],
[[[YY_ENDFUNCTION]], 313],
[[[YY_RECURSIVE]], 314],
[[[YY_RESULT]], 315],
[[[YY_SUBROUTINE]], 316],
[[[YY_ENDSUBROUTINE]], 317],
[[[YY_MODULE]], 318],
[[[YY_ENDMODULE]], 319],
[[[YY_BLOCK]], 320],
[[[YY_ENDBLOCK]], 321],
[[[_YY_DESCRIBER]], 322],
[[[YY_IMPLICIT]], 323],
[[[YY_NONE]], 324],
[[[YY_USE]], 325],
[[[YY_PARAMETER]], 326],
[[[YY_FORMAT]], 327],
[[[YY_ENTRY]], 328],
[[[YY_DIMENSION]], 329],
[[[YY_ARRAYINITIAL_START]], 330],
[[[YY_ARRAYINITIAL_END]], 331],
[[[YY_INTENT]], 332],
[[[YY_IN]], 333],
[[[YY_OUT]], 334],
[[[YY_INOUT]], 335],
[[[YY_OPTIONAL]], 336],
[[[YY_LEN]], 337],
[[[YY_KIND]], 338],
[[[_YY_TYPEDEF]], 339],
[[[YY_INTEGER_T]], 340],
[[[YY_FLOAT_T]], 341],
[[[YY_STRING_T]], 342],
[[[YY_COMPLEX_T]], 343],
[[[YY_BOOL_T]], 344],
[[[YY_CHARACTER_T]], 345],
[[[_YY_COMMAND]], 346],
[[[YY_WRITE]], 347],
[[[YY_READ]], 348],
[[[YY_PRINT]], 349],
[[[YY_OPEN]], 350],
[[[YY_CLOSE]], 351],
[[[YY_CALL]], 352]])

m4_define([b4_symbol_destructors], 
[])

m4_define([b4_symbol_printers], 
[])

m4_define([b4_translate],
[[     0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     107,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     104,   105,   101,    99,   106,   100,     2,   102,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,   108,   103,
       2,    98,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,
      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
      95,    96,    97]])


m4_define([b4_use_push_for_pull_flag],
[[0]])


m4_define([b4_pact_ninf],
[[-163]])


m4_define([b4_conflict_list_heads],
[[     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0]])


m4_define([b4_toknum_max],
[[352]])


m4_define([b4_rhs],
[[   159,     0,    -1,     5,    -1,   103,    -1,    -1,    59,    -1,
     111,    -1,    -1,    77,   104,    78,   105,    -1,    77,   104,
      79,   105,    -1,    77,   104,    80,   105,    -1,    74,   104,
     119,   105,    -1,    74,   104,   121,   105,    -1,    81,    -1,
      71,    -1,    82,    98,   121,    -1,    83,    98,    23,    -1,
     106,   112,    -1,   106,   112,   113,    -1,    -1,   112,    -1,
     112,   114,    -1,    -1,    24,    -1,    23,    -1,    27,    -1,
      30,    -1,    31,    -1,    29,    -1,     1,   107,    -1,    25,
      -1,   116,    -1,   141,    -1,   121,   108,   121,    -1,   121,
     108,   121,   108,   121,    -1,   108,    -1,   118,    -1,   118,
     106,   119,    -1,   121,    -1,   121,   106,   122,    -1,   117,
     104,   122,   105,    -1,   120,    -1,   104,   121,   105,    -1,
     121,    99,   121,    -1,   121,   100,   121,    -1,   121,   101,
     121,    -1,   121,   102,   121,    -1,   121,    18,   121,    -1,
     100,   121,    -1,    99,   121,    -1,   121,    12,   121,    -1,
     121,    13,   121,    -1,   121,     9,   121,    -1,   121,    14,
     121,    -1,   121,    15,   121,    -1,   121,    16,   121,    -1,
      17,   121,    -1,   121,     7,   121,    -1,   121,     8,   121,
      -1,   121,    10,   121,    -1,   121,    11,   121,    -1,   115,
      -1,   117,    -1,   119,    -1,    -1,   121,   110,    -1,   142,
     110,    -1,   126,    -1,   124,    -1,   125,    -1,   129,    -1,
     128,    -1,   127,    -1,   137,    -1,   138,    -1,   139,    -1,
     149,    -1,   151,    -1,   152,    -1,    41,   110,    -1,    42,
     110,    -1,    51,   110,    -1,   121,    98,   121,   110,    -1,
      68,    69,   110,    -1,   123,    -1,   123,   130,    -1,    -1,
      -1,   104,    -1,    -1,   105,    -1,   106,    -1,    -1,   101,
      -1,    23,    -1,   101,    -1,    27,    -1,   104,   134,   106,
     135,   105,    -1,   135,   133,    -1,    92,   136,   122,   110,
      -1,    94,   136,   122,   110,    -1,    93,   136,   122,   110,
      -1,   104,   114,   105,    -1,    -1,    85,   140,    -1,    86,
     140,    -1,    87,   140,    -1,    88,   140,    -1,    89,   140,
      -1,    90,   140,    -1,   141,   113,    19,   144,    -1,   116,
      -1,   116,    98,   121,    -1,   116,    98,   148,    -1,   143,
      -1,   143,   106,   144,    -1,    -1,   121,   106,   116,    98,
     121,   106,   121,    -1,    75,   122,    76,    -1,    75,   145,
      76,    -1,    35,    -1,    -1,   146,    -1,   146,   106,   148,
      -1,    34,   121,    35,   110,   130,    33,    34,   110,    -1,
      34,   121,    35,   110,   130,    36,   110,   130,    33,    34,
     110,    -1,    34,   121,    35,   110,   130,   150,    33,    34,
     110,    -1,    34,   121,    35,   110,   130,   150,    36,   110,
     130,    33,    34,   110,    -1,    34,   121,   147,   123,    -1,
      37,   121,    35,   110,   130,    -1,    37,   121,    35,   110,
     130,   150,    -1,    39,   110,   130,    33,    39,   110,    -1,
      39,   116,    98,   121,   106,   121,   110,   130,    33,    39,
     110,    -1,    39,   116,    98,   121,   106,   121,   106,   121,
     110,   130,    33,    39,   110,    -1,    52,   121,   110,   130,
      33,    39,   110,    -1,    49,    47,   131,   121,   132,   110,
     154,    33,    49,   110,    -1,    47,   131,   119,   132,   110,
     130,    -1,   153,    -1,   153,   154,    -1,   111,    57,   116,
     104,   144,   105,    60,   104,   116,   105,   110,   130,    33,
      57,   110,    -1,    25,    -1,    -1,    55,   156,   110,   130,
      33,    55,   156,   110,    -1,   155,    -1,   157,    -1,   158,
      -1,   158,   159,    -1]])


m4_define([b4_last],
[[1314]])


m4_define([b4_stos_min],
[[0]])


m4_define([b4_tag_seen_flag],
[[0]])


m4_define([b4_token_table_flag],
[[0]])


m4_define([b4_parser_file_name],
[[for90.tab.cpp]])


m4_define([b4_table_min],
[[-145]])


m4_define([b4_table],
[[    62,   -19,   115,    13,    13,  -145,     8,    72,    74,    75,
      17,    77,   148,   149,   150,   139,   104,   105,   152,   211,
      87,   108,   251,   125,    16,   252,   219,    73,    10,   131,
     114,   198,   132,   203,    87,   133,    62,   104,   105,   134,
     135,   136,   108,   119,    82,    83,    84,    85,    86,    18,
      12,   228,     1,   -64,   229,   230,     2,    62,   129,   130,
       1,   213,   214,   215,     2,    19,    16,   120,   104,   105,
      67,    20,    21,    16,    68,    22,    76,    23,    24,    25,
     180,   -64,   -64,    79,   -64,   -64,   116,   -64,   117,   -64,
     -64,   104,   105,   140,    88,   -64,   108,   -64,    80,   -64,
     -64,    14,    14,   175,   112,   113,    97,   280,    88,    62,
     126,    89,    92,    93,    62,   127,   -64,   169,   171,   142,
     224,   172,   173,   177,   -64,   174,   205,   186,   191,   192,
     193,   181,   182,    34,    35,    36,    37,    38,    39,   187,
     -64,   -64,   -64,   183,   195,   184,   188,    43,    44,   194,
     206,   -64,    45,   -64,   204,   117,   144,   210,   217,   235,
      62,   227,   226,   236,   238,   239,   240,   244,    18,   241,
     199,   120,   245,   120,   248,   255,   222,   110,   111,   112,
     113,   261,   265,   271,    19,   272,   232,   274,   279,   234,
      20,    21,    16,   281,    22,   284,    23,    24,    25,   286,
     263,   288,   208,   292,   296,   268,   230,   295,   300,   249,
     170,   302,    69,   254,   185,   258,   197,   277,   269,    71,
     289,   218,   176,   294,   283,    78,   285,   247,   262,   287,
     246,   270,   266,    11,    62,   196,    94,    95,    96,    62,
       0,   273,   199,   260,   275,   276,     0,   278,     0,   303,
       0,    62,    34,    35,    36,    37,    38,    39,    62,     0,
      62,   290,     0,    62,   293,     0,    43,    44,   297,   298,
       0,    45,     0,     0,     0,   301,     0,     0,     0,     0,
     304,     0,   305,    62,   147,   147,   147,     0,     0,     0,
     147,   153,   154,   155,   156,   157,   158,   159,   160,   161,
     162,   163,   164,   165,   166,   167,   168,     0,     0,     0,
      18,     0,     0,     0,   -64,     0,     0,     0,     0,   178,
       0,   179,     0,     0,     0,     0,    19,     0,     0,     0,
       0,     0,    20,    21,    16,     0,    22,     0,    23,    24,
      25,     0,   -64,   -64,     0,   -64,   -64,     0,   -64,     0,
     -64,   -64,     0,     0,     0,     0,   -64,     0,   -64,     0,
     -64,   -64,     0,     0,     0,   200,     0,     0,     0,     0,
       0,     0,     0,     0,   212,     0,   216,   -64,     0,     0,
       0,   147,   147,   221,     0,     0,     0,     0,     0,     0,
       0,     0,   223,     0,    34,    35,    36,    37,    38,    39,
     233,   -64,   -64,   -64,    18,     0,     0,     0,    43,    44,
       0,     0,   -64,    45,     0,     0,     0,   144,     0,     0,
      19,     0,     0,   250,     0,     0,    20,    21,    16,    18,
      22,     0,    23,    24,    25,   259,   147,     0,     0,     0,
       0,     0,     0,     0,     0,    19,   267,     0,     0,     0,
       0,    20,    21,    16,     0,    22,     0,    23,    24,    25,
       0,     0,   147,     0,     0,   282,     0,     0,     0,     0,
      98,    99,   100,   101,   102,   103,   104,   105,   106,   107,
       0,   108,     0,     0,   299,     0,     0,     0,    34,    35,
      36,    37,    38,    39,    98,    99,   100,   101,   102,   103,
     104,   105,    43,    44,   -64,   108,     0,    45,   -64,     0,
       0,   144,     0,    34,    35,    36,    37,    38,    39,    18,
       0,     0,     0,     0,     0,     0,     0,    43,    44,     0,
       0,     0,    45,     0,     0,    19,   144,     0,     0,     0,
       0,    20,    21,    16,    18,    22,     0,    23,    24,    25,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      19,     0,   110,   111,   112,   113,    20,    21,    16,   189,
      22,   190,    23,    24,    25,     0,   -84,    26,     0,   -84,
     -84,     0,    27,     0,    28,    29,   110,   111,   112,   113,
     -84,     0,    30,     0,    31,    32,     0,     0,     0,     0,
       0,     0,     0,    34,    35,    36,    37,    38,    39,     0,
       0,    33,     0,     0,     0,     0,     0,    43,    44,     0,
       0,     0,    45,     0,     0,     0,   144,     0,    34,    35,
      36,    37,    38,    39,    18,    40,    41,    42,     0,     0,
       0,     0,    43,    44,     0,     0,     0,    45,     0,     0,
      19,     0,     0,     0,     0,     0,    20,    21,    16,     0,
      22,     0,    23,    24,    25,     0,   -86,    26,     0,   -86,
     -86,     0,    27,     0,    28,    29,     0,     0,     0,     0,
       0,     0,    30,     0,    31,    32,     0,     0,    98,    99,
     100,   101,   102,   103,   104,   105,   106,   107,     0,   108,
       0,    33,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,    18,     0,     0,     0,     0,     0,    34,    35,
      36,    37,    38,    39,     0,    40,    41,    42,    19,     0,
       0,     0,    43,    44,    20,    21,    16,    45,    22,     0,
      23,    24,    25,     0,   -86,    26,     0,     0,    18,     0,
      27,     0,    28,    29,     0,     0,     0,     0,   -86,     0,
      30,     0,    31,    32,    19,     0,     0,     0,     0,     0,
      20,    21,    16,     0,    22,     0,    23,    24,    25,    33,
     110,   111,   112,   113,     0,     0,   237,   189,     0,   190,
      18,     0,     0,     0,     0,     0,    34,    35,    36,    37,
      38,    39,     0,    40,    41,    42,    19,     0,     0,     0,
      43,    44,    20,    21,    16,    45,    22,     0,    23,    24,
      25,     0,   -86,    26,     0,     0,     0,     0,    27,     0,
      28,    29,    34,    35,    36,    37,    38,    39,    30,     0,
      31,    32,     0,     0,     0,     0,    43,    44,     0,     0,
       0,    45,     0,     0,     0,     0,     0,    33,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,    18,     0,
       0,     0,     0,     0,    34,    35,    36,    37,    38,    39,
       0,    40,    41,    42,    19,     0,     0,     0,    43,    44,
      20,    21,    16,    45,    22,     0,    23,    24,    25,     0,
       0,    26,     0,     0,     0,     0,    27,     0,    28,    29,
       0,     0,     0,     0,     0,     0,    30,     0,    31,    32,
      13,     0,    98,    99,   100,   101,   102,   103,   104,   105,
     106,   107,     0,   108,     0,    33,    98,    99,   100,   101,
     102,   103,   104,   105,   106,   107,     0,   108,     0,     0,
       0,     0,    34,    35,    36,    37,    38,    39,     0,    40,
      41,    42,     0,     0,     0,     0,    43,    44,     0,     0,
       0,    45,    98,    99,   100,   101,   102,   103,   104,   105,
     106,   107,     0,   108,    98,    99,   100,   101,   102,   103,
     104,   105,   106,   107,     0,   108,    98,    99,   100,   101,
     102,   103,   104,   105,   106,   107,     0,   108,     0,     0,
       0,     0,     0,     0,   110,   111,   112,   113,    14,     0,
       0,   253,     0,     0,     0,     0,     0,     0,   110,   111,
     112,   113,     0,     0,     0,   243,    13,   190,    98,    99,
     100,   101,   102,   103,   104,   105,   106,   107,    13,   108,
      98,    99,   100,   101,   102,   103,   104,   105,   106,   107,
       0,   108,     0,     0,   110,   111,   112,   113,     0,     0,
       0,     0,     0,   242,     0,     0,   110,   111,   112,   113,
       0,     0,     0,   207,     0,     0,     0,     0,   110,   111,
     112,   113,     0,     0,     0,   291,    98,    99,   100,   101,
     102,   103,   104,   105,   106,   107,     0,   108,    98,    99,
     100,   101,   102,   103,   104,   105,   106,   107,     0,   108,
       0,     0,     0,     0,     0,     0,     0,     0,     0,   109,
     110,   111,   112,   113,    14,     0,     0,     0,     0,     0,
       0,     0,   110,   111,   112,   113,    14,    98,    99,   100,
     101,   102,   103,   104,   105,   106,   107,     0,   108,    98,
      99,   100,   101,   102,   103,   104,   105,   106,   107,     0,
     108,     0,     0,    98,    99,   123,   101,   102,     0,   104,
     105,     0,     0,     0,   108,     0,     0,   264,   110,   111,
     112,   113,     0,     0,   151,     0,     0,     0,     0,     0,
     110,   111,   112,   113,     0,     0,   208,    98,    99,   100,
     101,   102,   103,   104,   105,   106,   107,     0,   108,    98,
      99,   100,   101,   102,   103,   104,   105,   106,     0,     0,
     108,     0,     0,     0,     0,     0,     0,     0,     0,   110,
     111,   112,   113,     0,     0,     0,     0,     0,     0,     0,
       0,   110,   111,   112,   113,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,   110,   111,   112,   113,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,   110,
     111,   112,   113,     0,     0,     0,     0,     0,     0,     0,
       0,   110,   111,   112,   113]])


m4_define([b4_conflicting_rules_max],
[[0]])


m4_define([b4_merger],
[[     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0]])


m4_define([b4_glr_flag],
[[0]])


m4_define([b4_percent_define_syncline(lr.keep-unreachable-states)],
[[]])


m4_define([b4_check_max],
[[302]])


m4_define([b4_spec_graph_file],
[[]])


m4_define([b4_rline_min],
[[0]])


m4_define([b4_toknum],
[[     0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,
     315,   316,   317,   318,   319,   320,   321,   322,   323,   324,
     325,   326,   327,   328,   329,   330,   331,   332,   333,   334,
     335,   336,   337,   338,   339,   340,   341,   342,   343,   344,
     345,   346,   347,   348,   349,   350,   351,   352,    61,    43,
      45,    42,    47,    59,    40,    41,    44,    10,    58]])


m4_define([b4_defgoto_max],
[[257]])


m4_define([b4_version],
[[2.7]])


m4_define([b4_translate_min],
[[0]])


m4_define([b4_pkgdatadir],
[[F:\Codes\CommonLib\winflex\data]])


m4_define([b4_pgoto_min],
[[-163]])


m4_define([b4_rhs_max],
[[159]])


m4_define([b4_pgoto],
[[  -163,   -20,  -163,    93,    46,    77,  -163,     0,  -163,  -163,
    -162,  -163,   193,   -79,    98,  -163,  -163,  -163,  -163,  -163,
    -163,   -49,   -37,   -60,  -163,  -163,    34,    71,  -163,  -163,
    -163,     9,   -15,  -163,  -163,  -140,  -163,  -163,  -163,     4,
    -163,   -62,  -163,  -163,  -163,   -25,  -163,    66,  -163,  -163,
     227]])


m4_define([b4_pact_max],
[[1212]])


m4_define([b4_debug_flag],
[[1]])


m4_define([b4_yacc_flag],
[[0]])


m4_define([b4_spec_verbose_file],
[[]])


m4_define([b4_conflict_list_heads_min],
[[0]])


m4_define([b4_tname],
[["$][end", "error", "$][undefined", "_YY_VOID", "YY_REQ_MORE", "YY_CRLF",
  "_YY_OP", "YY_GT", "YY_GE", "YY_EQ", "YY_LE", "YY_LT", "YY_NEQ",
  "YY_NEQV", "YY_EQV", "YY_ANDAND", "YY_OROR", "YY_NOT", "YY_POWER",
  "YY_DOUBLECOLON", "YY_NEG", "YY_POS", "_YY_TYPE", "YY_INTEGER",
  "YY_FLOAT", "YY_WORD", "YY_OPERATOR", "YY_STRING", "YY_ILLEGAL",
  "YY_COMPLEX", "YY_TRUE", "YY_FALSE", "_YY_CONTROL", "YY_END", "YY_IF",
  "YY_THEN", "YY_ELSE", "YY_ELSEIF", "YY_ENDIF", "YY_DO", "YY_ENDDO",
  "YY_CONTINUE", "YY_BREAK", "YY_WHILE", "YY_ENDWHILE", "YY_WHERE",
  "YY_ENDWHERE", "YY_CASE", "YY_ENDCASE", "YY_SELECT", "YY_ENDSELECT",
  "YY_GOTO", "YY_DOWHILE", "YY_DEFAULT", "_YY_DELIM", "YY_PROGRAM",
  "YY_ENDPROGRAM", "YY_FUNCTION", "YY_ENDFUNCTION", "YY_RECURSIVE",
  "YY_RESULT", "YY_SUBROUTINE", "YY_ENDSUBROUTINE", "YY_MODULE",
  "YY_ENDMODULE", "YY_BLOCK", "YY_ENDBLOCK", "_YY_DESCRIBER",
  "YY_IMPLICIT", "YY_NONE", "YY_USE", "YY_PARAMETER", "YY_FORMAT",
  "YY_ENTRY", "YY_DIMENSION", "YY_ARRAYINITIAL_START",
  "YY_ARRAYINITIAL_END", "YY_INTENT", "YY_IN", "YY_OUT", "YY_INOUT",
  "YY_OPTIONAL", "YY_LEN", "YY_KIND", "_YY_TYPEDEF", "YY_INTEGER_T",
  "YY_FLOAT_T", "YY_STRING_T", "YY_COMPLEX_T", "YY_BOOL_T",
  "YY_CHARACTER_T", "_YY_COMMAND", "YY_WRITE", "YY_READ", "YY_PRINT",
  "YY_OPEN", "YY_CLOSE", "YY_CALL", "'='", "'+'", "'-'", "'*'", "'/'",
  "';'", "'('", "')'", "','", "'\\n'", "':'", "$][accept", "crlf",
  "dummy_function_iden", "dummy_variable_iden_1", "dummy_variable_iden",
  "dummy_variable_spec", "literal", "variable", "callable", "slice",
  "dimen_slice", "function_array", "exp", "argtable", "stmt",
  "output_stmt", "input_stmt", "compound_stmt", "jump_stmt", "let_stmt",
  "dummy_stmt", "suite", "_optional_lbrace", "_optional_rbrace",
  "_optional_comma", "_optional_device", "_optional_formatter", "io_info",
  "write", "print", "read", "_type_kind", "type_spec", "var_def",
  "kwargtable", "paramtable", "_generate_stmt", "array_builder_elem",
  "_optional_then", "array_builder", "if_stmt", "elseif_stmt", "do_stmt",
  "select_stmt", "case_stmt_elem", "case_stmt", "function_decl",
  "_optional_name", "program", "wrapper", "fortran_program", ]b4_null[]])


m4_define([b4_defact],
[[     7,   141,     5,     0,   143,   144,     7,     0,   140,     4,
       0,   146,     1,     2,     3,     0,    30,     0,     0,     0,
      24,    23,    25,    28,    26,    27,     0,     4,     4,     4,
       0,     4,     0,     0,   103,   103,   103,   103,   103,   103,
       0,     0,     0,     0,     0,     0,    61,    31,    62,    41,
       4,     0,    68,    69,    67,    72,    71,    70,     0,    73,
      74,    75,    32,     4,    76,    77,    78,   116,    29,    56,
      32,   121,     0,     0,    79,    80,    87,    81,     4,     4,
      22,   104,   105,   106,   107,   108,   109,    96,    95,     0,
      92,     0,     0,     0,    49,    48,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,    65,    85,     0,     0,     0,    66,
     111,   114,     0,     4,     0,     0,     0,    88,     0,     0,
      83,    14,     0,     0,    13,     0,     0,    20,     0,    94,
      93,     0,    91,    98,    35,    36,    63,    38,     4,     4,
       4,    42,     0,    57,    58,    52,    59,    60,    50,    51,
      53,    54,    55,    47,     4,    43,    44,    45,    46,   141,
      17,   116,     0,   116,     0,     0,   128,     0,     0,    89,
       0,     0,     0,     0,     0,    21,   102,     0,     0,     0,
       0,    99,   101,   100,    40,    82,     4,    18,   110,     0,
     112,   122,   113,   115,     0,     0,     4,     0,    90,     4,
       0,     0,     0,     0,     0,     0,    15,    16,     0,    37,
      39,    33,   142,    38,     0,     0,     0,     0,     0,     4,
       0,     0,   131,     4,     0,     4,    11,    12,     8,     9,
      10,    97,     0,     0,   118,   119,   123,     0,     4,     0,
       0,     0,     4,     0,     0,    87,   137,     0,   134,    34,
      31,     4,   124,     0,     4,     4,     0,     4,     0,     0,
     138,     0,     0,     0,     0,     0,   126,     0,     0,     0,
      89,     4,     0,     0,     4,   129,     0,     0,     4,     4,
     135,     0,     0,   125,   130,     4,     0,   132,     0,   117,
       4,   127,     4,   136,   139,   133]])


m4_define([b4_tokens_number],
[[109]])


m4_define([b4_stos_max],
[[159]])


m4_define([b4_merger_min],
[[0]])


m4_define([b4_table_max],
[[305]])


m4_define([b4_spec_name_prefix],
[[]])


m4_define([b4_epilogue],
[[]b4_syncline(2084, [["for90.y"]])[

//extern "C" int yylex();

void yyerror(const char* s)
{
	fprintf(stderr, "%s\n", s);
	printf("line %d from %d len %d, current token is %s(id = %d) : %s \n", get_flex_state().parse_line, get_flex_state().parse_pos, get_flex_state().parse_len, get_intent_name(yylval.fs.CurrentTerm.token).c_str(), yylval.fs.CurrentTerm.token, yylval.fs.CurrentTerm.what.c_str());
	printf("context : %s ^ %s\n", global_code.substr(max(0, get_flex_state().parse_pos - 10), 10).c_str(), global_code.substr(get_flex_state().parse_pos, 10).c_str());
}
string tabber(string & src) {
	string newline;
	string ans = "";
	std::istringstream f(src);
	while (getline(f, newline) ) {
		ans += '\t';
		ans += newline;
		ans += '\n';
	}
	return ans;
}
ParseNode * flattern_bin(ParseNode * pn) {
	/* it cant work well because it create a whole noew tree copy too much */
	/* THIS ALGORITHM FLATTERNS A RIGHT-RECURSIVE BINARY TREE */
	if (pn->child.size() == 2) {
		ParseNode * newp = new ParseNode();
		/* child@{0@} is the only data node */
		newp->addchild(new ParseNode(*pn->child@{0@}));

		/* pn->child@{1@} is a **list** of ALREADY flatterned elements */
		//	e.g
		//	child@{0@} is 1 
		//	child@{1@} is @{2, 3, 4, 5@}
		for (int i = 0; i < pn->child@{1@}->child.size(); i++)
		{
			newp->addchild(new ParseNode(*pn->child@{1@}->child@{i@}));
		}
		newp->fs = pn->fs;
		newp->father = pn->father;
		delete pn;
		return newp;
	}
	else {
		return pn;
	}
}
void update_pos(YYSTYPE & current_node) {
	if (current_node.child.size() == 0) {
		/* do nothing */
	}
	else if (current_node.child.size() == 1) {
		current_node.fs.parse_pos = current_node.child@{0@}->fs.parse_pos;
		current_node.fs.parse_line = current_node.child@{0@}->fs.parse_line;
		current_node.fs.parse_len = current_node.child@{0@}->fs.parse_len;
		current_node.fs.line_pos = current_node.child@{0@}->fs.line_pos;
	}
	else {
		int tot_len = 0;
		for (int i = 0; i < current_node.child.size(); i++)
		{
			tot_len += current_node.child@{i@}->fs.parse_len;
		}
		current_node.fs.parse_pos = current_node.child@{0@}->fs.parse_pos;
		current_node.fs.parse_line = current_node.child@{0@}->fs.parse_line;
		current_node.fs.parse_len = tot_len;
		current_node.fs.line_pos = current_node.child@{0@}->fs.line_pos;
	}
}

int parse(std::string code) {
#ifdef USE_YACC
	set_buff(code);
	yyparse();
	release_buff();
#endif
	return 0;
}
]])


m4_define([b4_table_ninf],
[[-146]])


m4_define([b4_prhs],
[[     0,     0,     3,     5,     7,     8,    10,    12,    13,    18,
      23,    28,    33,    38,    40,    42,    46,    50,    53,    57,
      58,    60,    63,    64,    66,    68,    70,    72,    74,    76,
      79,    81,    83,    85,    89,    95,    97,    99,   103,   105,
     109,   114,   116,   120,   124,   128,   132,   136,   140,   143,
     146,   150,   154,   158,   162,   166,   170,   173,   177,   181,
     185,   189,   191,   193,   195,   196,   199,   202,   204,   206,
     208,   210,   212,   214,   216,   218,   220,   222,   224,   226,
     229,   232,   235,   240,   244,   246,   249,   250,   251,   253,
     254,   256,   258,   259,   261,   263,   265,   267,   273,   276,
     281,   286,   291,   295,   296,   299,   302,   305,   308,   311,
     314,   319,   321,   325,   329,   331,   335,   336,   344,   348,
     352,   354,   355,   357,   361,   370,   382,   392,   405,   410,
     416,   423,   430,   442,   456,   464,   475,   482,   484,   487,
     503,   505,   506,   515,   517,   519,   521]])


m4_define([b4_check],
[[    15,    19,    51,     5,     5,     0,    25,    27,    28,    29,
      10,    31,    91,    92,    93,    23,    13,    14,    97,   181,
      27,    18,    33,    72,    25,    36,   188,    27,    57,    71,
      50,   171,    74,   173,    27,    77,    51,    13,    14,    81,
      82,    83,    18,    63,    35,    36,    37,    38,    39,     1,
       0,    33,    55,     5,    36,    37,    59,    72,    78,    79,
      55,    78,    79,    80,    59,    17,    25,    67,    13,    14,
     104,    23,    24,    25,   107,    27,    47,    29,    30,    31,
     129,    33,    34,    69,    36,    37,    33,    39,   106,    41,
      42,    13,    14,   101,   101,    47,    18,    49,   104,    51,
      52,   103,   103,   123,   101,   102,   104,   269,   101,   124,
      98,   104,    41,    42,   129,   104,    68,    55,    19,   106,
     199,    98,   106,    33,    76,   105,   175,   105,   148,   149,
     150,   104,   104,    85,    86,    87,    88,    89,    90,   106,
      92,    93,    94,    98,   164,    98,   106,    99,   100,   105,
      39,   103,   104,   105,    60,   106,   108,    33,    23,    39,
     175,   104,   106,   105,   105,   105,   105,    76,     1,   105,
      75,   171,    76,   173,    34,    47,   196,    99,   100,   101,
     102,   105,    34,    33,    17,    98,   206,    33,    33,   209,
      23,    24,    25,    49,    27,    34,    29,    30,    31,    33,
     249,    39,   105,    33,    33,   254,    37,    34,    57,   229,
     117,    39,    19,   233,   137,   235,   170,   266,   255,    26,
     280,   187,   124,   285,   273,    32,   275,   227,   248,   278,
     226,   256,   252,     6,   249,   169,    43,    44,    45,   254,
      -1,   261,    75,   243,   264,   265,    -1,   267,    -1,   298,
      -1,   266,    85,    86,    87,    88,    89,    90,   273,    -1,
     275,   281,    -1,   278,   284,    -1,    99,   100,   288,   289,
      -1,   104,    -1,    -1,    -1,   295,    -1,    -1,    -1,    -1,
     300,    -1,   302,   298,    91,    92,    93,    -1,    -1,    -1,
      97,    98,    99,   100,   101,   102,   103,   104,   105,   106,
     107,   108,   109,   110,   111,   112,   113,    -1,    -1,    -1,
       1,    -1,    -1,    -1,     5,    -1,    -1,    -1,    -1,   126,
      -1,   128,    -1,    -1,    -1,    -1,    17,    -1,    -1,    -1,
      -1,    -1,    23,    24,    25,    -1,    27,    -1,    29,    30,
      31,    -1,    33,    34,    -1,    36,    37,    -1,    39,    -1,
      41,    42,    -1,    -1,    -1,    -1,    47,    -1,    49,    -1,
      51,    52,    -1,    -1,    -1,   172,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,   181,    -1,   183,    68,    -1,    -1,
      -1,   188,   189,   190,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,   199,    -1,    85,    86,    87,    88,    89,    90,
     207,    92,    93,    94,     1,    -1,    -1,    -1,    99,   100,
      -1,    -1,   103,   104,    -1,    -1,    -1,   108,    -1,    -1,
      17,    -1,    -1,   230,    -1,    -1,    23,    24,    25,     1,
      27,    -1,    29,    30,    31,   242,   243,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    17,   253,    -1,    -1,    -1,
      -1,    23,    24,    25,    -1,    27,    -1,    29,    30,    31,
      -1,    -1,   269,    -1,    -1,   272,    -1,    -1,    -1,    -1,
       7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
      -1,    18,    -1,    -1,   291,    -1,    -1,    -1,    85,    86,
      87,    88,    89,    90,     7,     8,     9,    10,    11,    12,
      13,    14,    99,   100,    76,    18,    -1,   104,   105,    -1,
      -1,   108,    -1,    85,    86,    87,    88,    89,    90,     1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    99,   100,    -1,
      -1,    -1,   104,    -1,    -1,    17,   108,    -1,    -1,    -1,
      -1,    23,    24,    25,     1,    27,    -1,    29,    30,    31,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      17,    -1,    99,   100,   101,   102,    23,    24,    25,   106,
      27,   108,    29,    30,    31,    -1,    33,    34,    -1,    36,
      37,    -1,    39,    -1,    41,    42,    99,   100,   101,   102,
      47,    -1,    49,    -1,    51,    52,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    85,    86,    87,    88,    89,    90,    -1,
      -1,    68,    -1,    -1,    -1,    -1,    -1,    99,   100,    -1,
      -1,    -1,   104,    -1,    -1,    -1,   108,    -1,    85,    86,
      87,    88,    89,    90,     1,    92,    93,    94,    -1,    -1,
      -1,    -1,    99,   100,    -1,    -1,    -1,   104,    -1,    -1,
      17,    -1,    -1,    -1,    -1,    -1,    23,    24,    25,    -1,
      27,    -1,    29,    30,    31,    -1,    33,    34,    -1,    36,
      37,    -1,    39,    -1,    41,    42,    -1,    -1,    -1,    -1,
      -1,    -1,    49,    -1,    51,    52,    -1,    -1,     7,     8,
       9,    10,    11,    12,    13,    14,    15,    16,    -1,    18,
      -1,    68,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,     1,    -1,    -1,    -1,    -1,    -1,    85,    86,
      87,    88,    89,    90,    -1,    92,    93,    94,    17,    -1,
      -1,    -1,    99,   100,    23,    24,    25,   104,    27,    -1,
      29,    30,    31,    -1,    33,    34,    -1,    -1,     1,    -1,
      39,    -1,    41,    42,    -1,    -1,    -1,    -1,    47,    -1,
      49,    -1,    51,    52,    17,    -1,    -1,    -1,    -1,    -1,
      23,    24,    25,    -1,    27,    -1,    29,    30,    31,    68,
      99,   100,   101,   102,    -1,    -1,   105,   106,    -1,   108,
       1,    -1,    -1,    -1,    -1,    -1,    85,    86,    87,    88,
      89,    90,    -1,    92,    93,    94,    17,    -1,    -1,    -1,
      99,   100,    23,    24,    25,   104,    27,    -1,    29,    30,
      31,    -1,    33,    34,    -1,    -1,    -1,    -1,    39,    -1,
      41,    42,    85,    86,    87,    88,    89,    90,    49,    -1,
      51,    52,    -1,    -1,    -1,    -1,    99,   100,    -1,    -1,
      -1,   104,    -1,    -1,    -1,    -1,    -1,    68,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     1,    -1,
      -1,    -1,    -1,    -1,    85,    86,    87,    88,    89,    90,
      -1,    92,    93,    94,    17,    -1,    -1,    -1,    99,   100,
      23,    24,    25,   104,    27,    -1,    29,    30,    31,    -1,
      -1,    34,    -1,    -1,    -1,    -1,    39,    -1,    41,    42,
      -1,    -1,    -1,    -1,    -1,    -1,    49,    -1,    51,    52,
       5,    -1,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    -1,    18,    -1,    68,     7,     8,     9,    10,
      11,    12,    13,    14,    15,    16,    -1,    18,    -1,    -1,
      -1,    -1,    85,    86,    87,    88,    89,    90,    -1,    92,
      93,    94,    -1,    -1,    -1,    -1,    99,   100,    -1,    -1,
      -1,   104,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    -1,    18,     7,     8,     9,    10,    11,    12,
      13,    14,    15,    16,    -1,    18,     7,     8,     9,    10,
      11,    12,    13,    14,    15,    16,    -1,    18,    -1,    -1,
      -1,    -1,    -1,    -1,    99,   100,   101,   102,   103,    -1,
      -1,   106,    -1,    -1,    -1,    -1,    -1,    -1,    99,   100,
     101,   102,    -1,    -1,    -1,   106,     5,   108,     7,     8,
       9,    10,    11,    12,    13,    14,    15,    16,     5,    18,
       7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
      -1,    18,    -1,    -1,    99,   100,   101,   102,    -1,    -1,
      -1,    -1,    -1,   108,    -1,    -1,    99,   100,   101,   102,
      -1,    -1,    -1,   106,    -1,    -1,    -1,    -1,    99,   100,
     101,   102,    -1,    -1,    -1,   106,     7,     8,     9,    10,
      11,    12,    13,    14,    15,    16,    -1,    18,     7,     8,
       9,    10,    11,    12,    13,    14,    15,    16,    -1,    18,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    98,
      99,   100,   101,   102,   103,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    99,   100,   101,   102,   103,     7,     8,     9,
      10,    11,    12,    13,    14,    15,    16,    -1,    18,     7,
       8,     9,    10,    11,    12,    13,    14,    15,    16,    -1,
      18,    -1,    -1,     7,     8,    35,    10,    11,    -1,    13,
      14,    -1,    -1,    -1,    18,    -1,    -1,    35,    99,   100,
     101,   102,    -1,    -1,   105,    -1,    -1,    -1,    -1,    -1,
      99,   100,   101,   102,    -1,    -1,   105,     7,     8,     9,
      10,    11,    12,    13,    14,    15,    16,    -1,    18,     7,
       8,     9,    10,    11,    12,    13,    14,    15,    -1,    -1,
      18,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    99,
     100,   101,   102,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    99,   100,   101,   102,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    99,   100,   101,   102,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    99,
     100,   101,   102,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    99,   100,   101,   102]])


m4_define([b4_nterms_number],
[[51]])


m4_define([b4_rline_max],
[[2073]])


m4_define([b4_dprec],
[[     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0]])


m4_define([b4_percent_define_loc(lr.default-reductions)],
[[[[<default value>:-1.-1]], [[<default value>:-1.-1]]]])


m4_define([b4_rline],
[[     0,    52,    52,    57,    63,    68,    69,    70,    72,    82,
      93,   103,   125,   151,   160,   170,   174,   186,   192,   209,
     217,   223,   239,   247,   254,   260,   268,   274,   280,   289,
     292,   299,   299,   306,   321,   333,   348,   367,   389,   401,
     417,   451,   465,   479,   492,   505,   518,   531,   544,   556,
     568,   581,   594,   607,   620,   633,   646,   658,   671,   684,
     697,   710,   716,   724,   769,   779,   796,   809,   810,   811,
     812,   813,   823,   834,   835,   837,   839,   840,   841,   843,
     844,   845,   847,   862,   871,   881,   895,   907,   908,   909,
     910,   911,   912,   913,   918,   923,   928,   936,   948,   963,
    1000,  1044,  1090,  1096,  1104,  1116,  1126,  1136,  1146,  1156,
    1168,  1394,  1411,  1428,  1446,  1451,  1466,  1474,  1486,  1501,
    1524,  1525,  1526,  1535,  1547,  1563,  1582,  1600,  1621,  1637,
    1654,  1672,  1686,  1708,  1726,  1742,  1815,  1831,  1840,  1852,
    2037,  2038,  2040,  2050,  2056,  2064,  2073]])


m4_define([b4_prhs_min],
[[0]])


m4_define([b4_percent_define_bison_variables(lr.keep-unreachable-states)],
[[]])


m4_define([b4_spec_outfile],
[[for90.tab.cpp]])


m4_define([b4_translate_max],
[[108]])


m4_define([b4_user_token_number_max],
[[352]])


m4_define([b4_r1_min],
[[0]])


m4_define([b4_max_left_semantic_context],
[[0]])


m4_define([b4_pgoto_max],
[[227]])


m4_define([b4_rules_number],
[[146]])


m4_define([b4_file_name_all_but_ext],
[[for90.tab]])


m4_define([b4_error_verbose_flag],
[[0]])


m4_define([b4_percent_define(lr.type)],
[[lalr]])


m4_define([b4_r2_min],
[[0]])


m4_define([b4_pact],
[[    -3,   -19,  -163,   -29,  -163,  -163,     5,    50,  -163,    -2,
      41,  -163,  -163,  -163,  -163,   789,  -163,   -34,   -33,   747,
    -163,  -163,  -163,  -163,  -163,  -163,   747,    -1,    -2,    -2,
      29,    -2,   747,    14,    -6,    -6,    -6,    -6,    -6,    -6,
       7,     7,     7,   747,   747,   747,  -163,  -163,     2,  -163,
    1031,   543,  -163,  -163,  -163,  -163,  -163,  -163,    53,  -163,
    -163,  -163,   -18,    -2,  -163,  -163,  -163,    41,  -163,    55,
    -163,  1140,   789,    12,  -163,  -163,    11,  -163,  1043,    -2,
     -42,  -163,  -163,  -163,  -163,  -163,  -163,  -163,  -163,    -8,
      13,   309,   309,   309,    78,    78,  1089,   403,   747,   747,
     747,   747,   747,   747,   747,   747,   747,   747,   747,   747,
     747,   747,   747,   747,  -163,  -163,    62,   -42,    99,  -163,
      23,    16,    20,    -2,   867,    90,   747,  -163,   747,   789,
    -163,  -163,    27,    28,  -163,    45,    47,   -42,    22,  -163,
    -163,    33,  -163,  -163,  -163,    40,  -163,   463,    -2,    -2,
      -2,  -163,    44,    78,    78,  1166,    78,    78,  1166,  1200,
    1200,   487,  1212,    55,  1043,     3,     3,    24,    24,   -19,
      49,    41,   167,    41,    94,   633,  -163,   111,   977,  1101,
     124,   518,   -17,   747,   135,  -163,  -163,    -7,   518,    48,
     747,  -163,  -163,  -163,  -163,  -163,    -2,  -163,  -163,   428,
    1200,    56,  -163,  -163,    57,    18,    -2,   747,  -163,    -2,
     120,    58,   681,    59,    60,    61,  1200,  -163,    64,  -163,
    -163,   965,  -163,   929,    91,    96,    95,    41,   140,    -2,
     747,   -11,  -163,   915,   128,    -2,  -163,  -163,  -163,  -163,
    -163,  -163,   747,   428,  -163,  -163,  -163,    76,    -2,   789,
    1152,   148,    -2,   747,   789,    11,   128,   150,  -163,  1200,
      87,    -2,  -163,   154,    -2,    -2,   789,  1043,   155,   518,
    -163,   144,   747,   789,   161,   633,  -163,   166,   789,   162,
      97,    -2,   989,   170,    -2,   169,   173,   171,    -2,    -2,
    -163,   747,   151,  -163,  -163,    -2,   172,  -163,   711,  1200,
      -2,  -163,    -2,  -163,  -163,  -163]])


m4_define([b4_dprec_min],
[[0]])


m4_define([b4_defact_min],
[[0]])


m4_define([b4_percent_define(lr.keep-unreachable-states)],
[[false]])


m4_define([b4_synclines_flag],
[[1]])


m4_define([b4_nondeterministic_flag],
[[0]])


m4_define([b4_defines_flag],
[[1]])


m4_define([b4_conflict_list_heads_max],
[[0]])


m4_define([b4_dir_prefix],
[[]])


m4_define([b4_merger_max],
[[0]])


m4_define([b4_undef_token_number],
[[2]])


m4_define([b4_percent_define_bison_variables(lr.type)],
[[]])


m4_define([b4_percent_define_loc(lr.keep-unreachable-states)],
[[[[<default value>:-1.-1]], [[<default value>:-1.-1]]]])


m4_define([b4_prhs_max],
[[521]])


m4_define([b4_spec_file_prefix],
[[]])


m4_define([b4_r1_max],
[[159]])


m4_define([b4_percent_define_bison_variables(lr.default-reductions)],
[[]])


m4_define([b4_percent_define_loc(lr.type)],
[[[[<default value>:-1.-1]], [[<default value>:-1.-1]]]])


m4_define([b4_toknum_min],
[[0]])


m4_define([b4_percent_define(lr.default-reductions)],
[[most]])


m4_define([b4_spec_defines_file],
[[for90.tab.h]])


m4_define([b4_conflicting_rules_min],
[[0]])


m4_define([b4_r1],
[[     0,   109,   110,   110,   110,   111,   111,   111,   112,   112,
     112,   112,   112,   112,   112,   112,   112,   113,   113,   113,
     114,   114,   114,   115,   115,   115,   115,   115,   115,   115,
     116,   117,   117,   118,   118,   118,   119,   119,   119,   119,
     120,   121,   121,   121,   121,   121,   121,   121,   121,   121,
     121,   121,   121,   121,   121,   121,   121,   121,   121,   121,
     121,   121,   121,   122,   122,   123,   123,   123,   123,   123,
     123,   123,   123,   124,   124,   125,   126,   126,   126,   127,
     127,   127,   128,   129,   130,   130,   130,   131,   131,   132,
     132,   133,   133,   134,   134,   135,   135,   136,   136,   137,
     138,   139,   140,   140,   141,   141,   141,   141,   141,   141,
     142,   143,   143,   143,   144,   144,   144,   145,   146,   146,
     147,   147,   148,   148,   149,   149,   149,   149,   149,   150,
     150,   151,   151,   151,   151,   152,   153,   154,   154,   155,
     156,   156,   157,   158,   158,   159,   159]])


m4_define([b4_pre_prologue],
[[]b4_syncline(1, [["for90.y"]])[

#include <stdio.h>
#include <string>
#include <sstream>
#include <iostream>
#include <stdarg.h>
#include <tuple>
#include "../tokenizer.h"
#include "../attribute.h"
#include "../parser.h"
#include "../cgen.h"
#include "../Function.h"

// 前置声明, 不然编译不过
void yyerror(const char* s); 
extern int yylex();
extern void set_buff(const std::string & code);
extern void release_buff();
#define YYDEBUG 1
#define YYERROR_VERBOSE
#define MAX_CODE_LENGTH 65535
char codegen_buf@{MAX_CODE_LENGTH@};
using namespace std;
]])


m4_define([b4_r2],
[[     0,     2,     1,     1,     0,     1,     1,     0,     4,     4,
       4,     4,     4,     1,     1,     3,     3,     2,     3,     0,
       1,     2,     0,     1,     1,     1,     1,     1,     1,     2,
       1,     1,     1,     3,     5,     1,     1,     3,     1,     3,
       4,     1,     3,     3,     3,     3,     3,     3,     2,     2,
       3,     3,     3,     3,     3,     3,     2,     3,     3,     3,
       3,     1,     1,     1,     0,     2,     2,     1,     1,     1,
       1,     1,     1,     1,     1,     1,     1,     1,     1,     2,
       2,     2,     4,     3,     1,     2,     0,     0,     1,     0,
       1,     1,     0,     1,     1,     1,     1,     5,     2,     4,
       4,     4,     3,     0,     2,     2,     2,     2,     2,     2,
       4,     1,     3,     3,     1,     3,     0,     7,     3,     3,
       1,     0,     1,     3,     8,    11,     9,    12,     4,     5,
       6,     6,    11,    13,     7,    10,     6,     1,     2,    15,
       1,     0,     8,     1,     1,     1,     2]])


m4_define([b4_check_min],
[[-1]])


m4_define([b4_states_number],
[[306]])


m4_define([b4_r2_max],
[[15]])


m4_define([b4_dprec_max],
[[0]])


m4_define([b4_defgoto],
[[    -1,    15,     3,   137,   118,   138,    46,    47,    48,   145,
     146,    49,    50,   220,    51,    52,    53,    54,    55,    56,
      57,    58,   128,   209,   143,   141,    90,    91,    59,    60,
      61,    81,    70,    63,   121,   122,   225,   201,   124,   202,
      64,   231,    65,    66,   256,   257,     4,     9,     5,     6,
       7]])


m4_define([b4_defact_max],
[[146]])


m4_define([b4_stos],
[[     0,    55,    59,   111,   155,   157,   158,   159,    25,   156,
      57,   159,     0,     5,   103,   110,    25,   116,     1,    17,
      23,    24,    27,    29,    30,    31,    34,    39,    41,    42,
      49,    51,    52,    68,    85,    86,    87,    88,    89,    90,
      92,    93,    94,    99,   100,   104,   115,   116,   117,   120,
     121,   123,   124,   125,   126,   127,   128,   129,   130,   137,
     138,   139,   141,   142,   149,   151,   152,   104,   107,   121,
     141,   121,   110,   116,   110,   110,    47,   110,   121,    69,
     104,   140,   140,   140,   140,   140,   140,    27,   101,   104,
     135,   136,   136,   136,   121,   121,   121,   104,     7,     8,
       9,    10,    11,    12,    13,    14,    15,    16,    18,    98,
      99,   100,   101,   102,   110,   130,    33,   106,   113,   110,
     116,   143,   144,    35,   147,   130,    98,   104,   131,   110,
     110,    71,    74,    77,    81,    82,    83,   112,   114,    23,
     101,   134,   106,   133,   108,   118,   119,   121,   122,   122,
     122,   105,   122,   121,   121,   121,   121,   121,   121,   121,
     121,   121,   121,   121,   121,   121,   121,   121,   121,    55,
     112,    19,    98,   106,   105,   110,   123,    33,   121,   121,
     130,   104,   104,    98,    98,   114,   105,   106,   106,   106,
     108,   110,   110,   110,   105,   110,   156,   113,   144,    75,
     121,   146,   148,   144,    60,   130,    39,   106,   105,   132,
      33,   119,   121,    78,    79,    80,   121,    23,   135,   119,
     122,   121,   110,   121,   122,   145,   106,   104,    33,    36,
      37,   150,   110,   121,   110,    39,   105,   105,   105,   105,
     105,   105,   108,   106,    76,    76,   148,   116,    34,   110,
     121,    33,    36,   106,   110,    47,   153,   154,   110,   121,
     116,   105,   110,   130,    35,    34,   110,   121,   130,   131,
     154,    33,    98,   110,    33,   110,   110,   130,   110,    33,
     119,    49,   121,   130,    34,   130,    33,   130,    39,   132,
     110,   106,    33,   110,   150,    34,    33,   110,   110,   121,
      57,   110,    39,   130,   110,   110]])


m4_define([b4_final_state_number],
[[12]])


m4_define([b4_defgoto_min],
[[-1]])


m4_define([b4_file_name],
[["for90.y"]])


m4_define([b4_percent_define_syncline(lr.default-reductions)],
[[]])


m4_define([b4_percent_define_syncline(lr.type)],
[[]])


m4_define([b4_locations_flag],
[[0]])


m4_define([b4_rhs_min],
[[-1]])


m4_define([b4_pact_min],
[[-163]])


m4_define([b4_conflicting_rules],
[[     0]])


